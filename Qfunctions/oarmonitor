#!/usr/bin/perl
# $Id: oarmonitor 598 2007-07-05 08:13:30Z neyron $
# Feed the monitoring table

use strict;
use warnings;
use Data::Dumper;
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use Getopt::Long;
use oarversion;
use oar_Tools;
use oar_iolib;
use Fcntl;
use Storable qw(dclone);

init_conf($ENV{OARCONFFILE});
my $Monitor_file = get_conf("OARMONITOR_SENSOR_FILE");
$Monitor_file = oar_Tools::get_default_monitor_sensor_file() if (!defined($Monitor_file));
$Monitor_file = "$ENV{OARDIR}/$Monitor_file" if ($Monitor_file !~ /^\//);

my $Taktuk_cmd = get_conf("TAKTUK_CMD");
if (!defined($Taktuk_cmd)){
    warn("ERROR: TAKTUK_CMD must be defined in $ENV{OARCONFFILE}.\n");
    exit(1);
}

my $Openssh_cmd = get_conf("OPENSSH_CMD");
$Openssh_cmd = oar_Tools::get_default_openssh_cmd() if (!defined($Openssh_cmd));

Getopt::Long::Configure("gnu_getopt");
my $Version;
my $Job_id;
my $Frequency = 60;
my $Frequency_min = 1;
my $sos;
GetOptions ("version|V" => \$Version,
            "job_id|j=i" => \$Job_id,
            "frequency|f" => \$Frequency,
            "help|h" => \$sos
           );

# Display command help
sub usage {
    print <<EOS;
Usage: $0 [-h] [-V] [-f seconds] -j jobid
Feed the table monitoring from the database with data retrived on each nodes
of the job.
Options:
  -j, --job_id              job id to monitor
  -f, --frequency           number of seconds between each data collect
                            (default is $Frequency s)
  -h, --help                show this help screen
  -V, --version             print OAR version number
EOS
}

if (defined($sos)){
    usage();
    exit(0);
}

if (defined($Version)){
    print("OAR version : ".oarversion::get_version()."\n");
    exit(0);
}

if (!defined($Job_id)){
    usage();
    exit(2);
}

my $base = iolib::connect();

my $cpuset_name = iolib::get_job_cpuset_name($base, $Job_id);

# Dispatch via taktuk
pipe(tak_node_read,tak_node_write);
pipe(tak_stdin_read,tak_stdin_write);
pipe(tak_stdout_read,tak_stdout_write);
my $pid = fork;
if($pid == 0){
    #CHILD
    undef($base);
    $SIG{CHLD} = 'DEFAULT';
    $SIG{TERM} = 'DEFAULT';
    $SIG{INT}  = 'DEFAULT';
    $SIG{QUIT} = 'DEFAULT';
    $SIG{USR1} = 'DEFAULT';
    $SIG{USR2} = 'DEFAULT';
    my $cmd = "$Taktuk_cmd -c '$Openssh_cmd' ".'-o output=\'"OUTPUT $host $line\n"\''." -f '<&=".fileno(tak_node_read)."' broadcast exec [ perl - $cpuset_name ], broadcast file_input [ - ], broadcast close";
    fcntl(tak_node_read, F_SETFD, 0);
    close(tak_node_write);
    close(tak_stdout_read);
    close(STDOUT);
    # Redirect taktuk output into the pipe
    open(STDOUT, ">& tak_stdout_write");

    # Use the child STDIN to send the user command
    close(tak_stdin_write);
    close(STDIN);
    open(STDIN, "<& tak_stdin_read");

    exec($cmd);
    warn("[ERROR] Cannot execute $cmd\n");
    exit(-1);
}
close(tak_node_read);
close(tak_stdin_read);
close(tak_stdout_write);

# Send node list
my @hosts = iolib::get_job_current_hostnames($base,$Job_id);
if ($#hosts < 0){
    warn("The job $Job_id does not have currently assigned hostnames\n");
    exit(4);
}
my $hosts_hash;
foreach my $n (@hosts){
    $hosts_hash->{$n} = 1;
    print(tak_node_write "$n\n");
}
close(tak_node_write);

# Send perl script to all nodes
if (open(SENSOR, $Monitor_file)){
    while(<SENSOR>){
        print(tak_stdin_write $_);
    }
    print(tak_stdin_write "\n__END__\n");
    close(SENSOR);
}else{
    warn("Cannot read the monitor sensor file $Monitor_file\n");
    exit(3);
}

sub exit_monitor(){
    print(tak_stdin_write "STOP\n");
}

$SIG{TERM} = \&exit_monitor;
$SIG{INT} = \&exit_monitor;

my $tmp_hosts_hash;
my $nb_end_nodes = $#hosts + 1;
my $stop = 0;
my $tic = 0;
my $tic_time = time();
my $tic_time_prev = $tic_time;
while (($stop == 0) and ($nb_end_nodes > $#hosts)){
    sleep(time() - $tic_time);
    eval{
        $SIG{ALRM} = sub { die "alarm\n" };
        alarm($Frequency + 30);
        print(tak_stdin_write "$tic\n");
        
        $tic_time_prev = $tic_time;
        $tic_time = time();
        # Check the taktuk STDOUT
        $tmp_hosts_hash = dclone($hosts_hash);
        $nb_end_nodes = 0;
        while (($nb_end_nodes <= $#hosts) and (<tak_stdout_read>)){
            if ($_ =~ /^OUTPUT\s+([\w\.\-\d]+)\s+END$/){
                delete($tmp_hosts_hash->{$1}) if (defined($tmp_hosts_hash->{$1}));
                $nb_end_nodes++;
                $stop++;
            }elsif ($_ =~ /^OUTPUT\s+([\w\.\-\d]+)\s+(\w+)\s+(.+)$/){
                if (($3 eq "STOP") or ($3 eq "STOP_REQUESTED") or ($3 eq "ERROR")){
                    warn("$1 $2 $3\n");
                    $stop++;
                }else{
                    print("$1 $2 $3\n");
                }
            }else{
                warn("[TAKTUK OUTPUT] $_");
            }
        }
        alarm(0);
    };
    $tic++;
}
close(tak_stdin_write);
close(tak_stdout_read);

if ($stop > 0){
    warn("$stop sensors stopped to retrieve data.\n");
    exit(0);
}

my @bads = keys(%{$tmp_hosts_hash});
if ($#bads >= 0){
    warn("Some nodes timeouted: @bads\n");
    exit(5);
}

