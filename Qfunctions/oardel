#!/usr/bin/perl
# $Id$
# delete a job

use strict;
use warnings;
use Data::Dumper;
use DBI();
use oar_iolib;
#use IO::Socket::INET;
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use oar_Tools;
use Getopt::Long;
use oarversion;

my $exitValue = 0;

# Display command help
sub usage {
    print <<EOS;
Usage: $0 [-c][job_ids][-h][-v]
Delete or send checkpoint signal to jobs.
Options:
  -h, --help              show this help screen
  -c, --checkpoint        send checkpoint signal to the job_id
      --sql               delete/checkpoint jobs which respond to the SQL
                          where clause on the table jobs
                          (ex: "project = 'p1'")
  -v, --version           print OAR version number
EOS
    exit(1);
}

# Retrieve informations from OAR configuration file
init_conf($ENV{OARCONFFILE});
my $remote_host = get_conf("SERVER_HOSTNAME");
my $remote_port = get_conf("SERVER_PORT");

my $Openssh_cmd = get_conf("OPENSSH_CMD");
$Openssh_cmd = oar_Tools::get_default_openssh_cmd() if (!defined($Openssh_cmd));

if (is_conf("OAR_RUNTIME_DIRECTORY")){
    oar_Tools::set_default_oarexec_directory(get_conf("OAR_RUNTIME_DIRECTORY"));
}

# Parse command line
Getopt::Long::Configure("gnu_getopt");
my $Checkpoint;
my $sos;
my $Version;
my $Sql_property;
GetOptions ("checkpoint|c" => \$Checkpoint,
            "help|h" => \$sos,
            "sql=s"   => \$Sql_property,
            "version|v" => \$Version
           );

if (defined($sos)){
    usage();
    exit(0);
}

if (defined($Version)){
    print("OAR version : ".oarversion::get_version()."\n");
    exit(0);
}

if (($#ARGV < 0) and (!defined($Sql_property))){
    usage();
    exit(1);
}

my @job_ids;
foreach my $j (@ARGV) {
    if ($j =~ m/^\d+$/m){
        push(@job_ids,$j);
    }else{
        $exitValue = 4;
        warn("[ERROR] \"$j\" is not a valid OAR job identifier.\n");
    }
}
if (defined($Sql_property)){
    my $db = iolib::connect_ro();
    foreach my $j (iolib::get_jobs_with_given_properties($db,$Sql_property)){
        push(@job_ids, $j->{job_id});
    }
    iolib::disconnect($db);
}

my $base = iolib::connect();
# oardel is used to checkpoint some jobs
if (defined($Checkpoint)){
    foreach my $idJob (@job_ids){
        print("Checkpointing the job $idJob ...");
        # Try to insert checkpoint informations in the database
        my $err = iolib::ask_checkpoint_job($base,$idJob); 
        if ($err > 0) {
            print("ERROR.\n");
            if ($err == 1){
                warn("Cannot checkpoint $idJob ; You are not the right user.\n");
                $exitValue = 1;
            }elsif ($err == 3){
                warn("Cannot checkpoint $idJob ; The job is Interactive.\n");
                $exitValue = 7;
            }else{
                warn("Cannot checkpoint $idJob ; This job is not running.\n");
                $exitValue = 5;
            }
        }else{
            my $strComment;
            # Retrieve node names used by the job
            my @hosts = iolib::get_job_current_hostnames($base,$idJob);
            my $timeoutSSH = oar_Tools::get_ssh_timeout();
            # Timeout the ssh command
            eval {
                $SIG{ALRM} = sub { die "alarm\n" };
                alarm($timeoutSSH);
                oar_Tools::signal_oarexec($hosts[0],$idJob,"SIGUSR2",1, $base, $Openssh_cmd);
                alarm(0);
            };
            if ($@){
                print("ERROR.\n");
                if ($@ eq "alarm\n"){
                    $exitValue = 3;
                    $strComment = "Cannot contact $hosts[0], operation timouted ($timeoutSSH s).";
                    warn("$strComment\n");
                    iolib::add_new_event($base,"CHECKPOINT_ERROR",$idJob,$strComment);
                }else{
                    $strComment = "An unknown error occured.";
                    warn("$strComment\n");
                    iolib::add_new_event($base,"CHECKPOINT_ERROR",$idJob,$strComment);
                }
            }else{
                print("DONE.\n");
                $strComment = "The job $idJob was notified to checkpoint itself (send SIGUSR2).";
                print("$strComment\n");
                iolib::add_new_event($base,"CHECKPOINT_SUCCESS",$idJob,$strComment);
            }
        }
    }
}else{
    # oardel is used to delete some jobs
    my @jobRegistered;
    foreach my $idJob (@job_ids) {
        print("Deleting the job = $idJob ...");
        # Try to insert delete informations in the database
        iolib::lock_table($base,["frag_jobs","event_logs","jobs"]);
        my $err = iolib::frag_job($base,$idJob);
        iolib::unlock_table($base);
        if ($err == -1) {
            print("ERROR.\n");
            warn("Cannot frag $idJob ; You are not the right user.\n");
            $exitValue = 1;
        }elsif ($err == -2){
            print("ERROR.\n");
            warn("Cannot frag $idJob ; This job was already killed.\n");
            $exitValue = 6;
	}else{
            print("REGISTERED.\n");
            push(@jobRegistered,$idJob);
        }

    }
    if (@jobRegistered){
        #Signal Almigthy
        my $strError = oar_Tools::notify_tcp_socket($remote_host,$remote_port,"ChState");
        $strError = oar_Tools::notify_tcp_socket($remote_host,$remote_port,"Qdel") if (!defined($strError));
        if (defined($strError)){
            warn("$strError\n");
            $exitValue = 2;
        }else{
            print("The job(s) [ @jobRegistered ] will be deleted in a near future.\n");
        }
    }
}

iolib::disconnect($base);

exit($exitValue);
