#!/usr/bin/perl
# $Id$
# change node state dynamically

use strict;
use DBI();
use Data::Dumper;
use oar_iolib;
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use Sys::Hostname;
use Getopt::Long;
use oar_Tools;
use oarversion;

$| = 1;

my $exit_code = 0;

my @hostnames;
my $base;
my $state ;
my $nowaitMode;
my @properties;
my $new_resource;
my $sos;
my @resource;
my $Sql_property;

# Get OAR configuration
init_conf($ENV{OARCONFFILE});
my $remote_host = get_conf("SERVER_HOSTNAME");
my $remote_port = get_conf("SERVER_PORT");

sub set_hostname_properties($$$){
    my $base = shift;
    my $hostname = shift;
    my $arrayProp = shift;

    foreach my $p (@{$arrayProp}){
        if ($p =~ m/(.+)\s*=\s*(.+)/m){
            if (oar_Tools::check_resource_system_property($1) == 1){
                warn("/!\\ Cannot update property $1 because it is a system field.\n");
                $exit_code = 5;
                next;
            }
            print("Update property $1 with value $2 on node $hostname ...");
            my $ret = iolib::set_node_property($base,$hostname,$1,$2);
            if ($ret == 0){
                print("DONE\n");
            }else{
                print("ERROR (wrong property or wrong value)\n");
                $exit_code = 6;
            }
        }else{
            warn("/!\\ Bad property syntax : -p property=value\n");
            $exit_code = 7;
        }
    }
}


sub set_resource_properties($$$){
    my $base = shift;
    my $resource = shift;
    my $arrayProp = shift;

    foreach my $p (@{$arrayProp}){
        if ($p =~ m/(.+)\s*=\s*(.+)/m){
            if (oar_Tools::check_resource_system_property($1) == 1){
                warn("/!\\ Cannot update property $1 because it is a system field.\n");
                $exit_code = 8;
                next;
            }
            print("Update property $1 with value $2 ...");
            my $ret = iolib::set_resource_property($base,$resource,$1,$2);
            if ($ret == 0){
                print("DONE\n");
            }elsif($ret == 2){
                print("SAME (the property is already equal to the value)\n");
            }else{
                print("ERROR (wrong property or wrong value)\n");
                $exit_code = 9;
            }
        }else{
            warn("/!\\ Bad property syntax : -p property=value\n");
            $exit_code = 10;
        }
    }
}

sub wait_end_of_running_jobs($$){
    my $dbh = shift;
    my $job_list = shift;

    my $max_timeout = 30;
    my $jobInfo;
    foreach my $j (sort(@{$job_list})){
        $jobInfo = {'state' => 'Running'};
        # active waiting : it is not very nice but it works!!
        print("\t$j ");
        my $timeCount = 0;
        while ((($jobInfo->{'state'} ne "Terminated") and ($jobInfo->{'state'} ne "Error")) and ($timeCount < $max_timeout)){
            $jobInfo = iolib::get_job($dbh,$j);
            sleep(1);
            print(".");
            $timeCount++;
        }
        if ($timeCount >= $max_timeout){
            print(" Timouted\n");
            $exit_code = 11;
        }else{
            print(" Deleted\n");
        }
    }
    print("Check done\n");
}


# print explainations for the user and exit
sub usage {
    print <<EOS;
Usage: $0 [-h hostname | [[-r resource_number][--sql "sql syntax"] | -a]]
[-a] [-p "property=value"] [-s state]
Change the state and properties of a node in OAR.
You can also create a new resource.
Options:
 -a, --add                       add a new resource
 -s, --state=STATE               set the new state of the node
 -h, --hostname=HOSTNAME         set the node hostname
 -r, --resource                  set the resource
     --sql                       get resource identifiers which respond to the
                                 SQL where clause on the table jobs
                                 (ex: "type = 'default'")
 -p, --property="PROPERTY=VALUE" set the property of the node to the given
                                 value
 -n, --nowait                    do not wait for job end when the node
                                 switches to Absent or Dead
     --help                      display this help
 -V, --version                   print OAR version number
N.B.:
 - The states allowed are: Alive, Absent or Dead.
 - If not specified, the hostname will be retrieved via the 'hostname'
   utility.
 - You cannot specify "-a" and "-r" together.
EOS
    exit(1);
}


my $Version;
# Options on arg command line
Getopt::Long::Configure ("gnu_getopt");
GetOptions ("state|s=s" => \$state,
            "hostname|h=s"   => \@hostnames,
            "nowait|n" => \$nowaitMode,
            "property|p=s" => \@properties,
            "add|a" => \$new_resource,
            "help" => \$sos,
            "sql=s"   => \$Sql_property,
            "resource|r=i" => \@resource,
            "version|V" => \$Version
           );

usage() if (defined($sos));

if (defined($Version)){
    print("OAR version : ".oarversion::get_version()."\n");
    exit(0);
}

defined(@properties) || defined($state) || defined($new_resource) or usage();
if (defined($state) && !(($state eq 'Alive') || ($state eq 'Absent') || ($state eq 'Dead'))){
    warn("/!\\ Bad state value. Possibilities are : Alive | Absent | Dead \n");
    usage();
}

if (defined($Sql_property)){
    my $db = iolib::connect_ro();
    foreach my $r (iolib::get_resources_with_given_sql($db,$Sql_property)){
        push(@resource, $r);
    }
    iolib::disconnect($db);
    if ($#resource < 0){
        warn("/!\\ Your SQL clause returns nothing and there is no resource specified.\n");
        $exit_code = 12;
    }
}

if (defined($new_resource)){
    if (($#resource >= 0) or (defined($Sql_property))){
        warn("/!\\ You cannot use -r|--resource and (-a|--add or --sql) options together\n");
        usage();
    }
}

defined($hostnames[0]) or $hostnames[0] = hostname();
#print("$hostname\n");
my $base = iolib::connect() or die("Cannot connect to the database\n");

if (defined($new_resource)){
    # Create a new resources
    $state = "Alive" if (!defined($state));
    foreach my $h (@hostnames){
        print("new resource\n");
        print("$h added in the database\n");
        push(@resource,iolib::add_resource($base, $h, $state));
    }
    oar_Tools::notify_tcp_socket($remote_host,$remote_port,"ChState");
    oar_Tools::notify_tcp_socket($remote_host,$remote_port,"Term");
}else{
    if (($#resource >= 0) or (defined($Sql_property))){
        if (defined($state)){
            my @resources_to_check;
            foreach my $r (@resource){
                #$base->do("LOCK TABLE resources WRITE");
                if (iolib::set_resource_nextState($base,$r,$state) > 0){
                #$base->do("UNLOCK TABLES");
                    print("$r --> $state\n");
                    push(@resources_to_check, $r);
                }else{
                    warn("/!\\ The resource $r does not exist in OAR database.\n");
                    $exit_code = 3;
                }
            }
            oar_Tools::notify_tcp_socket($remote_host,$remote_port,"ChState");
            if (($state eq 'Dead') || ($state eq 'Absent')){
                if (!$nowaitMode){
                    foreach my $r (@resources_to_check){
                        print("Check jobs to delete on resource $r :\n");
                        my @jobs = iolib::get_resource_job($base,$r);
                        wait_end_of_running_jobs($base,\@jobs);
                    }
                }
            }elsif ($state eq 'Alive'){
                print("Done\n");
            }
        }
    }else{
        # update all resources with netwokAdress = $hostname
        if (defined($state)){
            my @nodes_to_check;
            foreach my $h (@hostnames){
                #$base->do("LOCK TABLE resources WRITE");
                if (iolib::set_node_nextState($base,$h,$state) > 0){
                #$base->do("UNLOCK TABLES");
                    print("$h --> $state\n");
                    push(@nodes_to_check, $h);
                }else{
                    warn("/!\\ The node $h does not exist in OAR database.\n");
                    $exit_code = 4;
                }
            }
            oar_Tools::notify_tcp_socket($remote_host,$remote_port,"ChState");
            if (($state eq 'Dead') || ($state eq 'Absent')){
                if (!$nowaitMode){
                    foreach my $h (@nodes_to_check){
                        print("Check jobs to delete on node $h :\n");
                        my @jobs = iolib::get_node_job($base,$h);
                        wait_end_of_running_jobs($base,\@jobs);
                    }
                }
            }
        }
    }
}

# Update properties
if (defined(@properties)){
    if (($#resource >= 0) or (defined($Sql_property))){
        foreach my $r (@resource){
            if (!defined(iolib::get_resource_info($base,$r))){
                warn("/!\\ The resource $r does not exist in OAR database.\n");
                $exit_code = 1;
            }else{
                set_resource_properties($base,$r,\@properties);
            }
        }
    }else{
        foreach my $h (@hostnames){
            if (iolib::is_node_exists($base,$h) == 0){
                warn("/!\\ The node $h does not exist in OAR database. First you must add it with -a|--add option.\n");
                $exit_code = 2;
            }else{
                set_hostname_properties($base,$h,\@properties);
            }
        }
    }
}


iolib::disconnect($base);

exit($exit_code);

