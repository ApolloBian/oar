#!/usr/bin/perl
# $Id$
#Sumbit job for execution

use strict;
use IO::Socket::INET;
use DBI();
use POSIX qw(strftime);
use Data::Dumper;
use Sys::Hostname;
use Getopt::Long;
use File::Basename;
use oar_iolib;
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use File::Temp qw/ tempfile /;
use oar_Tools;
use oarversion;

select(STDOUT);
$| = 1;

#Try to load XML module
my $XML_enabled = 1;
unless (eval "use XML::Simple qw(XMLout);1"){
    $XML_enabled = 0;
}

#Try to load YAML module
my $YAML_enabled = 1;
unless (eval "use YAML;1"){
    $YAML_enabled = 0;
}

# suitable Data::Dumper configuration for serialization
$Data::Dumper::Purity = 1;
$Data::Dumper::Terse = 1;
$Data::Dumper::Indent = 0;
$Data::Dumper::Deepcopy = 1;


#For interactive
my $remote_host;
my $remote_port;
my $Deploy_hostname;
my $Cosystem_hostname;
my $Cpuset_field;
my $Host = hostname ;

my $base;
my $Server;
my $Job_id;
my $Interactive = 0;
my $Reservation = "0";
my $Default_resources;
my $connect_job ;
my $Scan_script;
my @resource;
my $Queue_name;
my $Job_sql_properties = "";
my $Cmd_executor;
my $stagein = undef;
my $idFile = undef;
my $md5sum = undef;
my $stageindir;
my $sos;
my $Checkpoint=0;
my $notify;
my $job_name;
my $job_env;
my $job_hold;
my $Directory = $ENV{PWD};
my @Type;
my @Anterior_job;
my $Checkpoint_signal = 12; # SIGUSR2
my $Stdout_file;
my $Stderr_file;
my $Resubmit;
my $Cpuset_name;
my $Project = "default";
my $XML_mode;
my $YAML_mode;
my $DUMPER_mode;
my $job_key_file = "";
my $job_priv_key = "";
my $job_pub_key = "";


#to catch ^C signal
$SIG{INT} = 'qdel';
$SIG{HUP} = 'qdel';

# to address ^C in interactive submission
sub qdel($) {
    my $Al_dead = shift;
    
    if (defined($Job_id)) {
        if ($Al_dead eq "INT" ) {
            print(STDERR "\n\nCaught Interrupt (^C),");
        }
        warn("Deleting the job $Job_id ...\n");
        my $base = iolib::connect();
        iolib::lock_table($base,["frag_jobs","event_logs","jobs"]);
        my $err = iolib::frag_job($base,$Job_id);
        iolib::unlock_table($base);
        iolib::disconnect($base);
        warn("Job deleted\n");
        #Signal Almigthy
        oar_Tools::notify_tcp_socket($remote_host,$remote_port,"Qdel");
        exit(1);
    }
}

#Used when we must have a response from the server
sub init_tcp_server(){
    my $server = IO::Socket::INET->new( Type => SOCK_STREAM,
                                        Reuse => 1,
                                        Listen => 1
                                      ) or die("/!\\ Cannot initialize a TCP socket server.");
    my $server_port = $server->sockport();

    return($server,$server_port);
}

#Read user script and extract OAR submition options
sub scan_script($){
    my $file = shift;

    my %result;
    
    ($file) = split(" ",$file);
    #my $lusr= getpwuid($ENV{SUDO_UID});
    #open(FILE, "sudo -u $lusr cat $file 2> /dev/null|") or return(%result);
    
    if (open(FILE, $file)){
        if (<FILE> =~ /^#/){
            while (<FILE>) {
                if ( /^#OAR\s+/ ){
                    my $line = $_;
                    if ($line =~ m/^#OAR\s+(-l|--resource)\s*(.+)\s*$/m){
                        push(@{$result{resources}}, $2);
                    }elsif ($line =~ m/^#OAR\s+(-q|--queue)\s*(.+)\s*$/m) {
                        $result{queue} = $2;
                    }elsif ($line =~ m/^#OAR\s+(-p|--property)\s*"(.+)"\s*$/m) {
                        $result{property} = $2;
                    }
                }
            }
        }
        close(FILE);
    }else{
        warn("[ERROR] Cannot open the file $file. Check if it is readable by everybody (744).\n");
        exit(12);
    }

    return(%result);
}

# Connect to a job and give the shell of the user on te remote host
sub connect_job($$$){
    my $job_id = shift;
    my $stop_oarexec = shift;
    my $openssh_cmd = shift;
    
    my $dbh = iolib::connect_ro();
    my $lusr= getpwuid($ENV{SUDO_UID});
    my $job = iolib::get_job($dbh, $job_id);
    if ((($lusr eq $job->{job_user}) or ($lusr eq "oar")) && ($job->{state} eq "Running")) {
        my @hosts = iolib::get_job_current_hostnames($dbh,$job_id);
        my $host_to_connect_via_ssh = $hosts[0];
        #deploy, cosystem and no host part
        my $types = iolib::get_current_job_types($dbh,$job_id);
        if ((defined($types->{cosystem})) or ($#hosts < 0)){
            $host_to_connect_via_ssh = $Cosystem_hostname;
        }elsif (defined($types->{deploy})){
            $host_to_connect_via_ssh = $Deploy_hostname;
        }
        #deploy, cosystem and no host part
        if ((defined($Cpuset_field) and (!defined($types->{cosystem})) and (!defined($types->{deploy})) and ($#hosts >= 0))){
            $ENV{OAR_CPUSET} = iolib::get_job_cpuset_name($dbh,$job_id);
        }else{
            $ENV{OAR_CPUSET} = "";
        }
        my $moldable = iolib::get_current_moldable_job($dbh,$job->{assigned_moldable_job});
        iolib::disconnect($dbh);
        my @passinfo = getpwnam($lusr) or die("Cannot retrive system informations for user $lusr\n");
        my $shell=$passinfo[8];
        if ($ENV{DISPLAY} ne ""){
            print("Initialize X11 forwarding...\n");
            # first, get rid of remaining unused .Xautority.{pid} files...
            system({"bash"} "bash","-c",'for f in $HOME/.Xauthority.*; do [ -e "/proc/${f#$HOME/.Xauthority.}" ] || rm -f $f; done');
            $ENV{XAUTHORITY} = $ENV{HOME}."/.Xauthority.$$";
            system({"bash"} "bash","-c",'[ -x "/usr/bin/X11/xauth" ] && sudo -H -u "'.$lusr.'" bash -c "unset XAUTHORITY; xauth extract - ${DISPLAY#localhost}" | xauth -q merge - 2> /dev/null');
        }
        my $node_file = oar_Tools::get_default_oarexec_directory()."/$job_id";
        my $res_file = oar_Tools::get_default_oarexec_directory()."/$job_id"."_resources";
        my $oarsub_pids = oar_Tools::get_oarsub_connections_file_name($job_id);
        my $str = oar_Tools::get_oarexecuser_script_for_oarsub($node_file,$job_id,$lusr,$shell,$job->{launching_directory},$res_file,$job->{job_name},$job->{project},iolib::duration_to_sql($moldable->{moldable_walltime}), $moldable->{moldable_walltime}, $job->{job_env});
        my ($cmd_name,@cmd_opts) = split(" ",$openssh_cmd);
        my @cmd;
        my $i = 0;
        $cmd[$i] = $cmd_name;$i++;
        foreach my $p (@cmd_opts){
            $cmd[$i] = $p;$i++;
        }
        if ($ENV{OAR_CPUSET} ne ""){
            $cmd[$i] = "-oSendEnv=OAR_CPUSET";
            $i++;
        }
        if ($ENV{DISPLAY} ne ""){
            $cmd[$i] = "-X";
        }else{
            $cmd[$i] = "-x";
        }
        $i++;
        $cmd[$i] = "-t";$i++;
        $cmd[$i] = $host_to_connect_via_ssh;$i++;
        $str =~ s/\n//g;
        if ($ENV{DISPLAY} ne ""){
            $cmd[$i] = "bash -c 'echo \$PPID >> $oarsub_pids && (which xauth > /dev/null && xauth -q extract - \${DISPLAY#localhost} | sudo -H -u $lusr xauth merge -); TTY=\$(tty) && test -e \$TTY && sudo chown $lusr:oar \$TTY && sudo chmod 660 \$TTY' && sudo -H -u $lusr bash --noprofile --norc -c '$str'";$i++;
        }else{
            $cmd[$i] = "bash -c 'echo \$PPID >> $oarsub_pids && TTY=\$(tty) && test -e \$TTY && sudo chown $lusr:oar \$TTY && sudo chmod 660 \$TTY' && sudo -H -u $lusr bash --noprofile --norc -c '$str'";$i++;
        }
        #print("oarsub launchs command : @cmd\n");
        #essential : you become oar instead of the user
        #UID=EUID
        $< = $>;
        print("Connect to OAR job $job_id via the node $host_to_connect_via_ssh\n");
        system({$cmd[0]} @cmd);
        my $exit_value = $? >> 8;
        if ($exit_value == 2){
            warn("[ERROR] Cannot go into the working directory : $job->{launching_directory}\n");
        }elsif($exit_value != 0){
            warn("[ERROR] An unknown error occured : $?\n");
        }
        if ($stop_oarexec > 0){
            oar_Tools::signal_oarexec($host_to_connect_via_ssh, $job_id, "USR1", 0, undef, $openssh_cmd);
        }
        print("Disconnected from OAR job $job_id\n");
    }else{
        if ($job->{state} ne "Running"){
            warn("/!\\ ERROR : the job $job_id is not running. Its current state is $job->{state}.\n");
        }
        if (($lusr ne $job->{job_user}) and ($lusr ne "oar")){
            warn("/!\\ ERROR : you are not the right user for the job $job_id. This job is owned by $job->{job_user}.\n");
        }
        iolib::disconnect($dbh);
        return(20);
    }
    return(0);
}

#Print help message
sub usage() {
    print <<EOS;
Usage: $0 [OPTIONS] [-I|-C|<SCRIPT>]
Submit a job the OAR batch scheduler
Options are:
 -I, --Interactive             Request an interactive job. Open a login shell
                               on the first node of the reservation instead of
                               running a script.
 -C, --Connect=<OAR JOB ID>    Connect to a running job
 -l, --resource=<LIST>         Set the requested resources for the job.
                               The different parameters are resource properties
                               registered in OAR database, and `walltime' which
                               specifies the duration before the job must be 
                               automatically terminated if still running.
                               Walltime format is [hour:mn:sec|hour:mn|hour].
                               Ex: node=4/cpu=1,walltime=2:00:00
 -S, --Scanscript              Batch mode only: asks oarsub to scan the given
                               script for OAR directives (#OAR -l ...)
 -q, --queue=<QUEUE>           Set the the queue to submit the job to
 -p, --property="<LIST>"       Add constraints to properties for the job.
                               (format is a WHERE clause from the SQL syntax)
 -r, --reservation=<DATE>      Request a job start time reservation, 
                               instead of a submission. 
     --checkpoint=<DELAY>      Enable the checkpointing for the job. A signal 
                               is sent DELAY seconds before the walltime on
                               the first processus of the job 
     --signal=<SIG>            Specify the signal to use when checkpointing
                               (default is SIGUSR2)
 -t, --type=<TYPE>             Specify a specific type (deploy, besteffort,
                               cosystem, checkpoint, timesharing)
 -d, --directory=<DIR>         Specify the directory where to launch the
                               command (default is current directory)
     --project=<TXT>           Specify a name of a project the job belongs to
 -n, --name=<TXT>              Specify an arbitrary name for the job
 -e, --env=<TXT>               Environment variables to set on the running
                               proccess in the form "A=b C=d" (not implemented)
 -a, --anterior=<OAR JOB ID>   Anterior job that must be terminated to start
                               this new one
     --notify=<TXT>            Specify a notification method
                               (mail or command to execute). Ex: 
                                   --notify "mail:name\@domain.com"
                                   --notify "exec:/path/to/script args"
     --stdout=<FILE>           Specify the name of the standard output file
     --stderr=<FILE>           Specify the name of the error output file
     --resubmit<OAR JOB ID>    Resubmit the given job as a new one
     --force-cpuset-name=<TXT> Specify a cpuset name to use instead of the job
                               id (WARNING: if several jobs have the same
                               cpuset name then processes of a job could be
                               killed when another one finishes on the same
                               computer)
 -k, --job-key-file=<FILE>     Use a job key. Parameter is the pathname to the
                               secret key, public key is guessed (.pub is 
                               appended). If file does not already exist, 
                               generate it first.
     --job-priv-key=<TXT>      Use a job key. Raw private key provided inline
     --job-pub-key=<TXT>       Use a job key. Raw public key provided inline
     --hold                    Set the job state into Hold instead of Waiting,
                               so that it is not scheduled (you must run
                               "oarresume" to turn it into the Waiting state)
 -s, --stagein=<DIR|TGZ>       Set the stagein directory or archive
     --stagein-md5sum=<MD5SUM> Set the stagein file md5sum
 -D, --DUMPER                  Print result in DUMPER format
 -X, --XML                     Print result in XML format
 -Y, --YAML                    Print result in YAML format
 -h, --help                    Print this help message
 -v, --version                 Print OAR version number
EOS
}

# manage the job key if any:
# test job key files or inline keys existance.
# generate job keys if file specified but not existing
sub job_key_management() {
    if (($job_key_file ne "") and (($job_priv_key ne "") or ($job_pub_key ne ""))) {
        warn("Error: You must use either --job_key_file or the couple --job_priv_key and --job_pub_key, but not both\n");
        exit(15);
    }
    my $lusr= getpwuid($ENV{SUDO_UID});
    if ($job_key_file ne ""){
        # Test files with user privileges
        # generate key if neither pub or priv key file exists.
        system({"bash"} "bash","-c",'sudo -u '.$lusr.' bash -c \'[ -e "'.$job_key_file.'" -o -e "'.$job_key_file.'.pub" ]\'');
        if ($? != 0){
            print "Job key files do not exist, assuming they must be generated...\n";
            # ssh-keygen: no passphrase, smallest key (1024 bits), ssh2 rsa faster than dsa.
            if (system({"bash"} "bash","-c",'sudo -u "'.$lusr.'" ssh-keygen -b 1024 -C "Job key created by OAR" -N "" -t rsa -f "'.$job_key_file.'"')) {
                warn ("Error: Job key generation failed ($?).\n");
                exit(14);
            }
        }
        #unless ((-e $job_key_file) and (-e $job_key_file.".pub")) {
        system({"bash"} "bash","-c",'sudo -u '.$lusr.' bash -c \'[ -r "'.$job_key_file.'" -a -r "'.$job_key_file.'.pub" ]\'');
        if ($? != 0){
            warn ("Error: one or both of the job key's public and private parts cannot be read.\nCheck files: $job_key_file and $job_key_file.pub.\n");
            exit(14);
        }
				# read private and public key files: sudo -u user needed in order to be able to read the file for sure
        # safer way to do a `cmd`, see perl cookbook 
    		my $pid;
    		die "cannot fork: $!" unless defined ($pid = open(SAFE_CHILD, "-|"));
    		if ($pid == 0) {
            unless (exec("bash","-c",'sudo -u "'.$lusr.'" cat "'.$job_key_file.'"')) {
                warn ("Error: Cannot exec bash shell");
          	    exit(14);
    	      }
        } else {
            my @tmp_key;
            while (<SAFE_CHILD>) {
                push @tmp_key, $_;
            }
            $job_priv_key = join "",@tmp_key;
            close SAFE_CHILD;                 # $? contains status
    				if ($? != 0) {
                warn ("Error: Cannot read the private part of your job key: $job_key_file.\n");
                exit(14);
            } 
        }
    
    		die "cannot fork: $!" unless defined ($pid = open(SAFE_CHILD, "-|"));
    		if ($pid == 0) {
            unless (exec("bash","-c",'sudo -u "'.$lusr.'" cat "'.$job_key_file.'.pub"')) {
                warn ("Error: Cannot exec bash shell");
          	    exit(14);
    	      }
        } else {
            my @tmp_key;
            while (<SAFE_CHILD>) {
                push @tmp_key, $_;
            }
            $job_pub_key = join "",@tmp_key;
            close SAFE_CHILD;                 # $? contains status
    				if ($? != 0) {
                warn ("Error: Cannot read the public part of your job key: $job_key_file.pub.\n");
                exit(14);
            } 
        }
    }
    
    # last checks
    if (($job_priv_key ne "") or ($job_pub_key ne "")){
        if ($job_pub_key eq "") {
            warn("Error: missing job public key (private key found).\n");
            exit(15);
        } 
        if ($job_priv_key eq "") {
            warn("Error: missing job private key (public key found).\n");
            exit(15);
        } 
        if (defined($Cpuset_name)){
            warn("Error: it is not allowed to specify both a cpuset name and a job key.\n");
            exit(14);
        }
        if ($job_pub_key !~ /^(ssh-rsa|ssh-dss)\s/){
            warn("Error: Bad job key format. The public key must begin with either `ssh-rsa' or `ssh-dss'.\n");
            exit(14);
        }
        $job_pub_key =~ s/\n//g;
    }
}

# Parse -l options and return an array of hashtables with resources for a moldable job
sub parse_resource_descriptions($){
    my $resource_ref = shift;
    
    my @resource= @{$resource_ref};
    if ($#resource < 0){
        push(@resource,$Default_resources);
    }
    #print "--@resource--\n";

    my @result;
    foreach my $r (@resource){
        my @resource_groups;
        my $end_loop = 0;
        while ($end_loop == 0){
            my $initial_resource = $r;
            my %tmp_result;
            if ($r =~ /^\s*(\++|\,+|\s*)\s*\{(.+?)}(.*)$/){
                # $1 = property string
                $tmp_result{property} = $2;
                $r = $3;
            }
            
            my $resources_to_parse;
            if (($r =~ /^\s*(\++|\,+|\s*)\s*[\/]*([^\,\+]+)\s*(.*)$/) and ($2 !~ /^\s*walltime/)){
                $resources_to_parse = $2;
                $r = $3;
            }else{
                $Default_resources =~ /^\s*[\/]*(.+)$/;
                # Remove first /
                $resources_to_parse = $1;
            }
            my @slash_split = split('\/', $resources_to_parse);
            my @resources_list;
            foreach my $l (@slash_split){
                if ($l =~ /(\w+)\s*=\s*(\d+)/){
                    my $tmp = $1;
                    $tmp = "network_address" if ($tmp eq "nodes");
                    push(@resources_list, { resource => $tmp, value => $2 });
                }elsif ($l =~ /(\w+)\s*=\s*ALL/){
                    my $tmp = $1;
                    $tmp = "network_address" if ($tmp eq "nodes");
                    push(@resources_list, { resource => $tmp, value => -1 });
                }elsif ($l =~ /(\w+)\s*=\s*BEST/){
                    my $tmp = $1;
                    $tmp = "network_address" if ($tmp eq "nodes");
                    push(@resources_list, { resource => $tmp, value => -2 });
                }else{
                    die("/!\\ Cannot recognize the resource description : $l\n");
                }
            }
            $tmp_result{resources} = \@resources_list;
            
            if ($r =~ /^[\s\,]*walltime\s*=\s*([\d|:]+)\s*(\,.+|\s*)$/){
                #walltime part
                my ($w_h,$w_mn,$w_sec) = split(':',$1);
                if (defined($w_h)){
                    if (not defined($w_mn)){
                        $resource_groups[1] = "$w_h:00:00";
                    }elsif (not defined($w_sec)){
                        $resource_groups[1] = "$w_h:$w_mn:00";
                    }else{
                        $resource_groups[1] = "$w_h:$w_mn:$w_sec";
                    }
                    $resource_groups[1] = iolib::sql_to_duration("$resource_groups[1]");
                }else{
                    die("/!\\ Cannot recognize walltime resource value\n");
                }
                $r = $2;
            }
            if ($r eq $initial_resource){
                die("/!\\ Cannot recognize -- $r -- resource\n");
            }
            push(@{$resource_groups[0]}, \%tmp_result);

            if ($r =~ /^\s*$/){
                $end_loop = 1;
            }
        }
        push(@result, \@resource_groups);
    }
    return(@result);
}

#
# Main
#

init_conf($ENV{OARCONFFILE});
$remote_host = get_conf("SERVER_HOSTNAME");
$remote_port = get_conf("SERVER_PORT");
$stageindir = get_conf("STAGEIN_DIR");

$Default_resources = get_conf("OARSUB_DEFAULT_RESOURCES");
if (!defined($Default_resources)){
    $Default_resources = "/resource_id=1";
}

$Deploy_hostname = get_conf("DEPLOY_HOSTNAME");
if (!defined($Deploy_hostname)){
    $Deploy_hostname = $remote_host;
}

$Cosystem_hostname = get_conf("COSYSTEM_HOSTNAME");
if (!defined($Cosystem_hostname)){
    $Cosystem_hostname = $remote_host;
}

$Cpuset_field = get_conf("CPUSET_RESOURCE_PROPERTY_DB_FIELD");

my $binpath;
if (defined($ENV{OARDIR})){
    $binpath = $ENV{OARDIR}."/";
}else{
    die("OARDIR env variable must be defined\n");
}

my $Openssh_cmd = get_conf("OPENSSH_CMD");
$Openssh_cmd = oar_Tools::get_default_openssh_cmd() if (!defined($Openssh_cmd));


Getopt::Long::Configure ("gnu_getopt");
my $Version;
GetOptions ("resource|l=s" => \@resource,
            "queue|q=s"   => \$Queue_name,
            "Interactive|I"  => \$Interactive,
            "property|p=s" => \$Job_sql_properties,
            "reservation|r=s" => \$Reservation,
            "Connect|C=i" => \$connect_job,
            "stagein|s=s" => \$stagein,
            "stagein-md5sum=s" => \$md5sum,
            "checkpoint=i" => \$Checkpoint,
            "help|h" => \$sos,
            "notify=s" => \$notify,
            "type|t=s" => \@Type,
            "directory|d=s" => \$Directory,
            "name|n=s" => \$job_name,
            "project=s" => \$Project,
            "env|e=s" => \$job_env,
            "hold" => \$job_hold,
            "anterior|a=i" => \@Anterior_job,
            "signal=i" => \$Checkpoint_signal,
            "stdout=s" => \$Stdout_file,
            "stderr=s" => \$Stderr_file,
            "resubmit=i" => \$Resubmit,
            "force-cpuset-name=s" => \$Cpuset_name,
            "Scanscript|S" => \$Scan_script,
            "XML|X" => \$XML_mode,
            "YAML|Y" => \$YAML_mode,
            "DUMPER|D" => \$DUMPER_mode,
            "job-key-file|k=s" => \$job_key_file,
            "job-priv-key=s" => \$job_priv_key,
            "job-pub-key=s" => \$job_pub_key,
            "version|v" => \$Version
           );


if (defined($Version)){
    print("OAR version : ".oarversion::get_version()."\n");
    exit(0);
}

if (defined($sos)){
    usage();
    exit(0);
}

$base = iolib::connect();

if (defined($Resubmit)){
    print("Resubmitting job $Resubmit ...");
    my $err = iolib::resubmit_job($base,$Resubmit);
    if ($err > 0){
        $Job_id = $err;
        print("DONE\n");
        print("OAR_JOB_ID=$Job_id\n");
        if (defined(oar_Tools::notify_tcp_socket($remote_host,$remote_port,"Qsub"))){
            warn("Cannot connect to executor $remote_host:$remote_port. Is OAR started?\n");
            exit(3);
        }
        exit(0);
    }else{
        print("ERROR\n");
        if ($err == -1){
            warn("/!\\ An interactive job or a reservation cannot be resubmitted\n");
        }elsif ($err == -2){
            warn("/!\\ The job must be in Error or Terminated state\n");
        }elsif ($err == -3){
            warn("/!\\ You are not the right user\n");
        }elsif ($err == -4){
            warn("/!\\ Another active job is using the same ssh keys\n");
        }else{
            warn("/!\\ Unknown error\n");
        }
        exit(4);
    }
}

if ((@ARGV != 1) && ($Interactive == 0) && ($Reservation eq "0") && (!defined($connect_job))){
    usage();
    exit(5);
}

if (($Interactive == 1) and ($Reservation ne "0")){
    warn("/!\\ A reservation cannot be interactive.\n");
    usage();
    exit(6);
}

# stagein machinery
if (defined $stagein) {
    print "Setting up stagein...\n";
    if (-d $stagein) {
        print "Archiving the content of the directory \"$stagein\" for the job stagein...\n";
        my  (undef, $filename) = tempfile (SUFFIX=>".oar-stagein.tgz",OPEN => 0);
        system "tar cfz $filename $stagein" and die "Failed to archive the directory: $?\n";
        print "Stagein archive = $filename\n";
        print "(You may save this file if you plan to submit other jobs later with the same stagein)\n";
        $stagein = $filename;
        $md5sum = undef;
    }
    ( -r $stagein ) or die "Stagein file not found: $stagein\n";
    unless (defined $md5sum) {
        print "Computing stagein md5sum...\n";
        ($md5sum) = split(" ",`md5sum $stagein`);
        print "md5sum = $md5sum\n";
        print "(You may use the -m option with this md5sum for other job submitions with the same stagein)\n";
    }
    $base = iolib::connect();
    iolib::get_lock($base,$md5sum,3600) or die "Failed to lock stagein\n";
    $idFile = iolib::get_stagein_id($base,$md5sum);
    if (defined $idFile) {
        print "This stagein is already stored on the server.\n";
    } else {
        my $location = "$stageindir/$md5sum";
        my $method = "FILE";
        my $compression = "tar.gz";
        print "Uploading stagein...\n";
        system "scp $stagein $location" and die "Stagein upload failed\n";
        my @stats = stat $stagein;
        $idFile=iolib::set_stagein($base,$md5sum,$location,$method,$compression,$stats[7]);
        defined $idFile or die "Failed to setup stagein\n";
    }
    iolib::release_lock($base,$md5sum) or die "Failed to unlock stagein\n";
    iolib::disconnect($base);
    print "Stagein completed.\n";
}

# Connect to a reservation
if (defined($connect_job)){
    # Do not kill the job if the user close the window
    $SIG{HUP} = 'DEFAULT';
    exit(connect_job($connect_job,0,$Openssh_cmd));
}
# End connection to a reservation

job_key_management();

my $base_ro = iolib::connect_ro();

if (($Interactive == 0) and ($ARGV[0] ne "")) {
    my $exec = $ARGV[0];
    if (defined($Scan_script)){
        my %scan_result = scan_script($exec) if ($exec ne "");
        #print("$Queue_name \n");
        if (defined($scan_result{queue}) && !defined($Queue_name)){
            $Queue_name = $scan_result{queue}
        }elsif(defined($scan_result{queue}) && defined($Queue_name)){
            warn("/!\\ Ignore script value for queue parameter : $scan_result{queue}; another value was given on the command line.");
        }
        if (defined($scan_result{property}) && !defined($Job_sql_properties)){
            $Job_sql_properties = $scan_result{property}
        }elsif(defined($scan_result{property}) && defined($Job_sql_properties)){
            warn("/!\\ Ignore script value for property parameter : $scan_result{property}; another value was given on the command line.");
        }
        if (defined($scan_result{resources})){
            push(@resource, @{$scan_result{resources}});
        }
    }

    my @resource_list = parse_resource_descriptions(\@resource);

    #if (!($exec =~ m/^\/.+$/m)){
        # WARNING: we are not the real user, we are oar user!!!
        # so $exec properties are not correct
    #    if ( -e "$exec" ){
    #        $exec = $Directory."/".$exec ;
    #    }
    #}

    $Cmd_executor = "Qsub";

    my $server_port;
    if ($Reservation ne "0"){
        #Test if this job is a reservation and the syntax is right
        if ($Reservation =~ m/^\s*(\d{4}\-\d{1,2}\-\d{1,2})\s+(\d{1,2}:\d{1,2}:\d{1,2})\s*$/m){
            $Reservation = iolib::sql_to_local("$1 $2");
            print("$Reservation\n");
        }else{
            warn("Syntax error near -r or --reservation option. Reservation date exemple : \"2007-03-25 17:32:12\"\n");
            iolib::disconnect($base);
            exit(7);
        }
        ($Server, $server_port) = init_tcp_server();
    }

    $Job_id = iolib::add_micheline_job($base, $base_ro, "PASSIVE", \@resource_list, $exec, "$Host:$server_port", $Queue_name, $Job_sql_properties, $Reservation, defined ($idFile)?$idFile:"NULL", $Checkpoint, $Checkpoint_signal, $notify, $job_name,$job_env,\@Type, $Directory,\@Anterior_job,$Stdout_file,$Stderr_file,$Cpuset_name,$job_hold,$Project,$job_priv_key,$job_pub_key);
}else{
    if ($ARGV[0] ne ""){
        warn("/!\\ You asked for an Interactive job SO I will ignore arguments: $ARGV[0] ; Is your syntax right?\n");
    }
    $Cmd_executor = "Qsub -I";

    my @resource_list = parse_resource_descriptions(\@resource);
 
    if ($Reservation ne "0"){
        #Test if this job is a reservation and the syntax is right
        if ($Reservation =~ m/^\s*(\d{4}\-\d{1,2}\-\d{1,2})\s+(\d{1,2}:\d{1,2}:\d{1,2})\s*$/m){
            $Reservation = iolib::sql_to_local("$1 $2");
            print("$Reservation\n");
        }else{
            warn("Syntax error near -r or --reservation option. Reservation date exemple : \"2007-03-25 17:32:12\"\n");
            iolib::disconnect($base);
            exit(7);
        }
    }
    
    my $server_port;
    ($Server, $server_port) = init_tcp_server();

    $Job_id = iolib::add_micheline_job($base, $base_ro, "INTERACTIVE", \@resource_list, "", "$Host:$server_port", $Queue_name, $Job_sql_properties, $Reservation, defined ($idFile)?$idFile:"NULL", $Checkpoint, $Checkpoint_signal, $notify, $job_name,$job_env,\@Type, $Directory,\@Anterior_job,$Stdout_file,$Stderr_file,$Cpuset_name,$job_hold,$Project,$job_priv_key,$job_pub_key);
}
print("OAR_JOB_ID=$Job_id \n");

if ((defined($DUMPER_mode)) or (defined($YAML_mode) or ($XML_mode))){
    print("\n##########\n");
    my $tmp = { job_id => $Job_id };
    if (defined($DUMPER_mode)){
        print(Dumper($tmp));
    }elsif(defined($XML_mode)){
        if ($XML_enabled == 1){
            print(XMLout($tmp));
        }else{
            warn("[ERROR] Cannot load XML module.\n");
        }
    }elsif(defined($YAML_mode)){
        if ($YAML_enabled == 1){
            print(YAML::Dump($tmp));
        }else{
            warn("[ERROR] Cannot load YAML module.\n");
        }
    }
    print("\n##########\n\n");
}

iolib::disconnect($base_ro);
iolib::disconnect($base);

if ($Job_id < 0){
    warn("Error in oarsub, verify your syntax or call administrator\n");
    exit(8);
}

#Signal Almigthy
if (defined(oar_Tools::notify_tcp_socket($remote_host,$remote_port,"$Cmd_executor"))){
    #qdel(1);
    warn("Cannot connect to executor $remote_host:$remote_port so I kill this job. Is OAR started?\n");
    exit(9);
}

my $answer;
if ($Reservation ne "0"){
    #Reservation mode
    print("Reservation mode : waiting validation...\n");
    my $client = $Server->accept();
    $answer = <$client>;
    chop($answer);
    if ($answer eq "GOOD RESERVATION"){
        print("Reservation valid --> OK\n");
    }else{
        print("Reservation not valid --> KO ($answer)\n");
        exit(10);
    }
}elsif ($Interactive==1) {
    #Interactive mode
    print("Interactive mode : waiting...\n");
    my $prev_str = "";
    do{
        my $client = $Server->accept();
        $answer = <$client>;
        chop($answer);
        if (($answer ne $prev_str) and ($answer ne "GOOD JOB")){
            print("[".strftime("%F %T",localtime)."] $answer\n");
            $prev_str = $answer;
        }
    }while (($answer ne "GOOD JOB") and ($answer ne "BAD JOB") and ($answer ne "JOB KILLED") and ($answer !~ /^INVALID RESOURCES/));
    print("\n");
    if ($answer eq "GOOD JOB"){
        exit(connect_job($Job_id,1,$Openssh_cmd));
    }else{
        exit(11);
    }
}

exit(0);
