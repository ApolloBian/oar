#!/usr/bin/perl
#
#Sumbit job for execution

use strict;
use IO::Socket::INET;
use DBI();
use Data::Dumper;
use Sys::Hostname;
use Getopt::Long;
use File::Basename;
use oar_iolib;
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use File::Temp qw/ tempfile /;
use oar_Tools;

#For interactive
my $remote_host;
my $remote_port;
my $Deploy_hostname;
my $Host = hostname ;

my $base;
my $Server;
my $Job_id;
my $Interactive = 0;
my $Reservation = "0";
my $Default_resources;
my $connect_job ;
my @resource;
my $Queue_name;
my $Job_sql_properties = "";
my $Cmd_executor;
my $stagein = undef;
my $idFile = undef;
my $md5sum = undef;
my $stageindir;
my $sos;
my $Checkpoint=0;
my $notify;
my $job_name;
my $Directory = $ENV{PWD};
my @Type;
my @Anterior_job;
my $Checkpoint_signal = 12; # SIGUSR2
my $Stdout_file;
my $Stderr_file;

#to catch ^C signal
$SIG{'INT'} = 'qdel';

# to address ^C in interactive submission
sub qdel($) {
    my $Al_dead = shift;
    
    if (defined($Job_id)) {
        if ($Al_dead eq "INT" ) {
            print("\n\nCaught Interrupt (^C), Deleting the job $Job_id\n");
            my $base = iolib::connect();
            iolib::lock_table($base,["frag_jobs","event_logs","jobs"]);
            my $err = iolib::frag_job($base,$Job_id);
            iolib::unlock_table($base);
            iolib::disconnect($base);
            print("Job deleted\n");
            #Signal Almigthy
            oar_Tools::notify_tcp_socket($remote_host,$remote_port,"Qdel");
            exit(1);
        }
    }
}

#Used when we must have a response from the server
sub init_tcp_server(){
    my $server = IO::Socket::INET->new( Type => SOCK_STREAM,
                                        Reuse => 1,
                                        Listen => 1
                                      ) or die("/!\\ Cannot initialize a TCP socket server.");
    my $server_port = $server->sockport();

    return($server,$server_port);
}

#Read user script and extract OAR submition options
sub scan_script($){
    my $file = shift;

    my %result;

    my $lusr= getpwuid($ENV{SUDO_UID});
    open(FILE, "sudo -u $lusr cat $file 2> /dev/null|") or return(%result);

    if (<FILE> =~ /^#/){
        while (<FILE>) {
            if ( /^#OAR\s+/ ){
                my $line = $_;
                if ($line =~ m/^#OAR\s+(-l|--resource)\s*(.+)\s*$/m){
                    push(@{$result{resources}}, $2);
                }elsif ($line =~ m/^#OAR\s+(-q|--queue)\s*(.+)\s*$/m) {
                    $result{queue} = $2;
                }elsif ($line =~ m/^#OAR\s+(-p|--property)\s*"(.+)"\s*$/m) {
                    $result{property} = $2;
                }
            }
        }
    }
    close(FILE);

    return(%result);
}

# Connect to a job and give the shell of the user on te remote host
sub connect_job($$){
    my $job_id = shift;
    my $stop_oarexec = shift;
    
    my $dbh = iolib::connect_ro();
    my $lusr= getpwuid($ENV{SUDO_UID});
    my $job = iolib::get_job($dbh, $job_id);
    if ((($lusr eq $job->{job_user}) or ($lusr eq "oar")) && ($job->{state} eq "Running")) {
        my @hosts = iolib::get_job_current_hostnames($dbh,$job_id);
        my $host_to_connect_via_ssh = $hosts[0];
        #deploy part
        my $types = iolib::get_current_job_types($dbh,$job_id);
        if (defined($types->{deploy})){
            $host_to_connect_via_ssh = $Deploy_hostname;
        }
        #deploy part
        iolib::disconnect($dbh);
        my @passinfo = getpwnam($lusr) or die("Cannot retrive system informations for user $lusr\n");
        my $shell=$passinfo[8];
        my $display = "";
        if ($ENV{DISPLAY} ne ""){
            my ($host_part,$num_part) = split(':',$ENV{DISPLAY});
            $display = hostname().":$num_part";
        }
        my $node_file = oar_Tools::get_default_oarexec_directory()."/$job_id";
        #my $cmd = "ssh -t $host_to_connect_via_ssh \"sh -c \\\"TTY=\\\\\\\$(tty) && test -e \\\\\\\$TTY && sudo chown $lusr:oar \\\\\\\$TTY && sudo chmod 660 \\\\\\\$TTY \\\" && sudo su - $lusr -c \\\"oarexecuser.sh $node_file $job_id $lusr $shell $job->{launching_directory} I\\\"\"";
        my $str = oar_Tools::get_oarexecuser_script_for_oarsub($node_file,$job_id,$lusr,$shell,$job->{launching_directory},$display);
        my $cmd = "ssh -x -t $host_to_connect_via_ssh \"sh -c \\\"TTY=\\\\\\\$(tty) && test -e \\\\\\\$TTY && sudo chown $lusr:oar \\\\\\\$TTY && sudo chmod 660 \\\\\\\$TTY\\\" && sudo -H -u $lusr sh -c \'$str\'\"";
        #print("oarsub launchs command : $cmd\n");
        #essential : you become oar instead of the user
        #UID=EUID
        $< = $>;
        print("Connect to OAR job $job_id via the node $host_to_connect_via_ssh\n");
        system($cmd);
        if ($stop_oarexec > 0){
            oar_Tools::signal_oarexec($host_to_connect_via_ssh, $job_id, "USR1", 0, undef);
        }
        print("Disconnected from OAR job $job_id\n");
    }else{
        if ($job->{state} ne "Running"){
            print("/!\\ ERROR : the job $job_id is not running. Its current state is $job->{state}.\n");
        }
        if (($lusr ne $job->{job_user}) and ($lusr ne "oar")){
            print("/!\\ ERROR : you are not the right user for the job $job_id. This job is owned by $job->{job_user}.\n");
        }
        iolib::disconnect($dbh);
        return(1);
    }
    return(0);
}

#Print help message
sub usage() {
    print <<EOS;
Usage: oarsub [OPTIONS] [-I|<SCRIPT>]
Submit a job the OAR batch scheduler
Options are:
 -I, --Interactive             request an interactive job
 -l, --resource=<LIST>         set the resource list( ex: nodes=4/cpu=1,walltime=2:00:00 )
 -q, --queue=<QUEUE>           set the the queue to submit the job to
 -p, --property=<LIST>         set the property list
 -r, --reservation=<DATE>      request a reservation
 -C, --Connect=<JOB_ID>        connect to a running job
 -s, --stagein=<DIR|TGZ>       set the stagein directory or archive
     --stagein-md5sum=<MD5SUM> set the stagein file md5sum
 -k, --checkpoint              enable the job to be checkpointed
     --signal                  specify the signal to use when checkpointing (defuault is 12 --> SIGUSR2)
 -t, --type                    specify a specific type (deploy, besteffort, cosystem, checkpoint)
 -d, --directory               specify the directory where to launch the command (default is current directory)
 -n, --name                    specify an arbitrary name for the job
 -a, --anterior                anterior job that must be terminated to start this new one
     --notify                  specify a notification method(mail or program to launch); ex: 
                                   --notify "mail:name\@domain.com"
				   --notify "exec:/path/to/script args"
     --stdout                  specify the name of the standard output file
     --stderr                  specify the name of the error output file
 -h, --help                    print this help message
EOS
}

#
# Main
#

init_conf("oar.conf");
$remote_host = get_conf("SERVER_HOSTNAME");
$remote_port = get_conf("SERVER_PORT");
$stageindir = get_conf("STAGEIN_DIR");

$Default_resources = get_conf("OARSUB_DEFAULT_RESOURCES");
if (!defined($Default_resources)){
    $Default_resources = "/resource_id=1";
}
    

$Deploy_hostname = get_conf("DEPLOY_HOSTNAME");
if (!defined($Deploy_hostname)){
    $Deploy_hostname = $remote_host;
}

my $binpath;
if (defined($ENV{OARDIR})){
    $binpath = $ENV{OARDIR}."/";
}else{
    die("OARDIR env variable must be defined\n");
}

Getopt::Long::Configure ("gnu_getopt");

GetOptions ("resource|l=s" => \@resource,
            "queue|q=s"   => \$Queue_name,
            "Interactive|I"  => \$Interactive,
            "property|p=s" => \$Job_sql_properties,
            "reservation|r=s" => \$Reservation,
            "Connect|C=i" => \$connect_job,
            "stagein|s=s" => \$stagein,
            "stagein-md5sum=s" => \$md5sum,
            "checkpoint|k=i" => \$Checkpoint,
            "help|h" => \$sos,
            "notify=s" => \$notify,
            "type|t=s" => \@Type,
            "directory|d=s" => \$Directory,
            "name|n=s" => \$job_name,
            "anterior|a=i" => \@Anterior_job,
            "signal=i" => \$Checkpoint_signal,
	    "stdout=s" => \$Stdout_file,
	    "stderr=s" => \$Stderr_file
           );

if (defined($sos)){
    usage();
    exit(0);
}

if ((@ARGV != 1) && ($Interactive == 0) && ($Reservation == 0) && (!defined($connect_job))){
    usage();
    exit(1);
}

# stagein machinery
if (defined $stagein) {
    print "Setting up stagein...\n";
    if (-d $stagein) {
        print "Archiving the content of the directory \"$stagein\" for the job stagein...\n";
        my  (undef, $filename) = tempfile (SUFFIX=>".oar-stagein.tgz",OPEN => 0);
        system "tar cfz $filename $stagein" and die "Failed to archive the directory: $?\n";
        print "Stagein archive = $filename\n";
        print "(You may save this file if you plan to submit other jobs later with the same stagein)\n";
				$stagein = $filename;
        $md5sum = undef;
    }
    ( -r $stagein ) or die "Stagein file not found: $stagein\n";
    unless (defined $md5sum) {
        print "Computing stagein md5sum...\n";
		    ($md5sum) = split(" ",`md5sum $stagein`);
        print "md5sum = $md5sum\n";
        print "(You may use the -m option with this md5sum for other job submitions with the same stagein)\n";
    }
    $base = iolib::connect();
		iolib::get_lock($base,$md5sum,3600) or die "Failed to lock stagein\n";
    $idFile = iolib::get_stagein_id($base,$md5sum);
    if (defined $idFile) {
        print "This stagein is already stored on the server.\n";
    } else {
        my $location = "$stageindir/$md5sum";
        my $method = "FILE";
        my $compression = "tar.gz";
        print "Uploading stagein...\n";
        system "scp $stagein $location" and die "Stagein upload failed\n";
        my @stats = stat $stagein;
		    $idFile=iolib::set_stagein($base,$md5sum,$location,$method,$compression,$stats[7]);
        defined $idFile or die "Failed to setup stagein\n";
    }
    iolib::release_lock($base,$md5sum) or die "Failed to unlock stagein\n";
    iolib::disconnect($base);
    print "Stagein completed.\n";
}

$base = iolib::connect();

# Connect to a reservation
if (defined($connect_job)){
    exit(connect_job($connect_job,0));
}
# End connection to a reservation

# Parse -l options and return an array of hashtables with resources for a moldable job
sub parse_resource_descriptions($){
    my $resource_ref = shift;
    
    my @resource= @{$resource_ref};
    #print "@resource\n";

    my @result;
    foreach my $r (@resource){
        my @resource_groups;
        my $end_loop = 0;
        while ($end_loop == 0){
            my $initial_resource = $r;
            my %tmp_result;
            if ($r =~ /^\s*(\++|\,+|\s*)\s*\{(.+?)}(.*)$/){
                # $1 = property string
                $tmp_result{property} = $2;
                $r = $3;
            }
            if ($r =~ /^\s*(\++|\,+|\s*)\s*\/([^\,\+]+)\s*(.*)$/){
                $r = $3;
                my @slash_split = split('\/', $2);
                my @resources_list;
                foreach my $l (@slash_split){
                    if ($l =~ /(\w+)\s*=\s*(\d+)/){
                        push(@resources_list, { resource => $1, value => $2 });
                    }else{
                        die("/!\\ Cannot recognize the resource description : $l\n");
                    }
                }
                $tmp_result{resources} = \@resources_list;
            }
            if ($r =~ /^\s*\,*\s*walltime\s*=\s*([\d|:]+)\s*(\,.+|\s*)$/){
                #walltime part
                my ($w_h,$w_mn,$w_sec) = split(':',$1);
                if (defined($w_h)){
                    if (not defined($w_mn)){
                        $resource_groups[1] = $w_h.":00:00";
                    }elsif (not defined($w_sec)){
                        $resource_groups[1] = $w_h.":00";
                    }else{
                        $resource_groups[1] = $1;
                    }
                }else{
                    die("/!\\ Cannot recognize walltime resource value\n");
                }
                $r = $2;
            }
            if ($r eq $initial_resource){
                die("/!\\ Cannot recognize -- $r -- resource\n");
            }else{
                push(@{$resource_groups[0]}, \%tmp_result);
            }

            if ($r =~ /^\s*$/){
                $end_loop = 1;
            }
        }
        push(@result, \@resource_groups);
    }
    return(@result);
}

my $base_ro = iolib::connect_ro();

if ($Interactive == 0) {
    my $exec = $ARGV[0];
    my %scan_result = scan_script($exec) if ($exec ne "");
    print("$Queue_name \n");
    if (defined($scan_result{queue}) && !defined($Queue_name)){
        $Queue_name = $scan_result{queue}
    }elsif(defined($scan_result{queue}) && defined($Queue_name)){
        warn("/!\\ Ignore script value for queue parameter : $scan_result{queue}; another value was given on the command line.");
    }
    if (defined($scan_result{property}) && !defined($Job_sql_properties)){
        $Job_sql_properties = $scan_result{property}
    }elsif(defined($scan_result{property}) && defined($Job_sql_properties)){
        warn("/!\\ Ignore script value for property parameter : $scan_result{property}; another value was given on the command line.");
    }
    if (defined($scan_result{resources})){
        push(@resource, @{$scan_result{resource}});
    }

    if ($#resource < 0){
        push(@resource, $Default_resources);
    }
    my @resource_list = parse_resource_descriptions(\@resource);

    #if (!($exec =~ m/^\/.+$/m)){
        # WARNING: we are not the real user, we are oar user!!!
        # so $exec properties are not correct
    #    if ( -e "$exec" ){
    #        $exec = $Directory."/".$exec ;
    #    }
    #}

    $Cmd_executor = "Qsub";

    my $server_port;
    if ($Reservation ne "0"){
        ($Server, $server_port) = init_tcp_server();
    }

    $Job_id = iolib::add_micheline_job($base, $base_ro, "PASSIVE", \@resource_list, $exec, "$Host:$server_port", $Queue_name, $Job_sql_properties, $Reservation, defined ($idFile)?$idFile:"NULL", $Checkpoint, $Checkpoint_signal, $notify, $job_name, \@Type, $Directory,\@Anterior_job,$Stdout_file,$Stderr_file);
}else{
    $Cmd_executor = "Qsub -I";
    my $server_port;
    ($Server, $server_port) = init_tcp_server();

    if ($#resource < 0){
        push(@resource, $Default_resources);
    }
    my @resource_list = parse_resource_descriptions(\@resource);
    
    $Job_id = iolib::add_micheline_job($base, $base_ro, "INTERACTIVE", \@resource_list, "", "$Host:$server_port", $Queue_name, $Job_sql_properties, $Reservation, defined ($idFile)?$idFile:"NULL", $Checkpoint, $Checkpoint_signal, $notify, $job_name, \@Type, $Directory,\@Anterior_job,$Stdout_file,$Stderr_file);
}
print("IdJob = $Job_id \n");

iolib::disconnect($base_ro);
iolib::disconnect($base);

if ($Job_id < 0){
    warn("Error in oarsub, verify your syntax or call administrator\n");
    exit(2);
}

#Signal Almigthy
if (defined(oar_Tools::notify_tcp_socket($remote_host,$remote_port,"$Cmd_executor"))){
    qdel(1);
    warn("Cannot connect to executor $remote_host:$remote_port so I kill this job. Is OAR started?\n");
    exit(0);
}

my $answer;
if ($Reservation ne "0"){
    #Reservation mode
    print("Reservation mode : waiting validation\n");
    my $client = $Server->accept();
    $answer = <$client>;
    chop($answer);
    if ($answer eq "GOOD RESERVATION"){
        print("Reservation valid --> OK\n");
    }else{
        print("Reservation not valid --> KO ($answer)\n");
    }
}elsif ($Interactive==1) {
    #Interactive mode
    print("Interactive mode : waiting \n");
    my $client = $Server->accept();
    $answer = <$client>;
    chop($answer);
    if ($answer eq "GOOD JOB"){
        connect_job($Job_id,1);
    }else{
        print("Sorry but the system returned : $answer\n");
    }
}

exit 0;
