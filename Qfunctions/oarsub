#!/usr/bin/perl
#
#Sumbit job for execution

BEGIN {
    # Get library path for OAR modules
    $ENV{PERL5LIB} = $ENV{PERL5LIB}.":".$ENV{OARLIB};
}

use strict;
use IO::Socket::INET;
use DBI();
use Data::Dumper;
use Sys::Hostname;
use Getopt::Long;
use oar_iolib;
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use File::Temp qw/ tempfile /;
use oar_Tools;

#For interactive
my $remote_host;
my $remote_port;
my $deploy_hostname;
my $Host = hostname ;

my $base;
my $Job_id;
my $Interactive = 0;
my $Reservation = "0";
my $connectResa ;
my @Resource_list;
my @resource;
my $Queue_name;
my $Job_sql_properties;
my $Cmd_executor;
my $stagein = undef;
my $idFile = undef;
my $md5sum = undef;
my $stageindir;
my $sos;
my $Checkpoint=0;

#to catch ^C signal
$SIG{'INT'} = 'qdel';

# to address ^C in interactive submission
sub qdel($) {
    my $Al_dead = shift;
    if (defined($Job_id)) {
        if ($Al_dead eq "INT" ) {
            print("\n\nCaught Interrupt (^C), Deleting the job $Job_id\n");
        }
        $base = iolib::connect();
        my $err = iolib::frag_job($base,$Job_id);
        iolib::disconnect($base);
        print("Job deleted\n");
        #Signal Almigthy
        if ($Al_dead == 0) {
            oar_Tools::notifyAlmighty($remote_host,$remote_port,"Qdel");
            exit(1);
        }
    }
}

#Used when we must have a response from the server
sub init_tcp_server(){
    my $server = IO::Socket::INET->new( Type => SOCK_STREAM,
                                        Reuse => 1,
                                        Listen => 1
                                      ) or die("/!\\ Cannot initialize a TCP socket server.");
    my $server_port = $server->sockport();

    return($server,$server_port);
}

#Read user script and extract OAR submition options
sub scan_script($){
    my $file = shift;

    my %result;

    my $lusr= getpwuid($ENV{SUDO_UID});
    open(FILE, "sudo -u $lusr cat $file 2> /dev/null|") or return;

    if (<FILE> =~ /^#/){
        while (<FILE>) {
            if ( /^#OAR\s+/ ){
                my $line = $_;
                if ($line =~ m/^#OAR\s+(-l|--resource)\s*(.+)\s*$/m){
                    push(@{$result{resources}}, $2);
                }elsif ($line =~ m/^#OAR\s+\(-q|--queue)\s*(.+)\s*$/m) {
                    $result{queue} = $2;
                }elsif ($line =~ m/^#OAR\s+(-p|--property)\s*"(.+)"\s*$/m) {
                    $result{property} = $2;
                }
            }
        }
    }
    close(FILE);

    return(%return);
}


#Print help message
sub usage() {
    print <<EOS;
Usage: oarsub [OPTIONS] [-I|<SCRIPT>]
Submit a job the OAR batch scheduler
Options are:
 -I, --interactive             request an interactive job
 -l, --resource=<LIST>         set the resource list( ex: nodes=4/cpu=1,walltime=2:00:00 )
 -q, --queue=<QUEUE>           set the the queue to submit the job to
 -p, --property=<LIST>         set the property list
 -r, --reservation=<DATE>      request a reservation
 -c, --connect=<RESERVATION>   connect to a running job
 -s, --stagein=<DIR|TGZ>       set the stagein directory or archive
 -m, --stagein-md5sum=<MD5SUM> set the stagein file md5sum
 -k, --checkpoint              enable the job to be checkpointed
 -h, --help                    print this help message
EOS
}

#
# Main
#

init_conf("oar.conf");
$remote_host = get_conf("SERVER_HOSTNAME");
$remote_port = get_conf("SERVER_PORT");
$stageindir = get_conf("STAGEIN_DIR");

$deploy_hostname = get_conf("DEPLOY_HOSTNAME");
if (!defined($deploy_hostname)){
    $deploy_hostname = $remote_host;
}

my $binpath;
if (defined($ENV{OARDIR})){
    $binpath = $ENV{OARDIR}."/";
}else{
    die("OARDIR env variable must be defined\n");
}

Getopt::Long::Configure ("gnu_getopt");

GetOptions ("resource|l=s" => \@resource,
            "queue|q=s"   => \$Queue_name,
            "interactive|I"  => \$Interactive,
            "property|p=s" => \$Job_sql_properties,
            "reservation|r=s" => \$Reservation,
            "connect|c=i" => \$connectResa,
            "stagein|s=s" => \$stagein,
            "stagein-md5sum|m=s" => \$md5sum,
            "checkpoint|k=i" => \$Checkpoint,
            "help|h" => \$sos
           );

if (defined $sos){
    usage();
    exit(0);
}

if ((@ARGV != 1) && ($Interactive == 0) && ($Reservation == 0)){
    usage();
    exit(1);
}

# stagein machinery
if (defined $stagein) {
    print "Setting up stagein...\n";
    if (-d $stagein) {
        print "Archiving the content of the directory \"$stagein\" for the job stagein...\n";
        my  (undef, $filename) = tempfile (SUFFIX=>".oar-stagein.tgz",OPEN => 0);
        system "tar cfz $filename $stagein" and die "Failed to archive the directory: $?\n";
        print "Stagein archive = $filename\n";
        print "(You may save this file if you plan to submit other jobs later with the same stagein)\n";
				$stagein = $filename;
        $md5sum = undef;
    }
    ( -r $stagein ) or die "Stagein file not found: $stagein\n";
    unless (defined $md5sum) {
        print "Computing stagein md5sum...\n";
		    ($md5sum) = split(" ",`md5sum $stagein`);
        print "md5sum = $md5sum\n";
        print "(You may use the -m option with this md5sum for other job submitions with the same stagein)\n";
    }
    $base = iolib::connect();
		iolib::get_lock($base,$md5sum,3600) or die "Failed to lock stagein\n";
    $idFile = iolib::get_stagein_id($base,$md5sum);
    if (defined $idFile) {
        print "This stagein is already stored on the server.\n";
    } else {
        my $location = "$stageindir/$md5sum";
        my $method = "FILE";
        my $compression = "tar.gz";
        print "Uploading stagein...\n";
        system "scp $stagein $location" and die "Stagein upload failed\n";
        my @stats = stat $stagein;
		    $idFile=iolib::set_stagein($base,$md5sum,$location,$method,$compression,$stats[7]);
        defined $idFile or die "Failed to setup stagein\n";
    }
    iolib::release_lock($base,$md5sum) or die "Failed to unlock stagein\n";
    iolib::disconnect($base);
    print "Stagein completed.\n";
}

$base = iolib::connect();

# Connect to a reservation
if (defined($connectResa)){
    my $lusr= getpwuid($ENV{SUDO_UID});
    my $job = iolib::get_job($base, $connectResa);
    if ((($lusr eq $job->{'user'}) or ($lusr eq "oar")) && ($job->{'state'} eq "Running")) {
        my @hosts = iolib::get_job_current_hostnames($base,$connectResa);
        my $hostToConnectViaSSH = $hosts[0];
        #deploy part
        my %queuesInfo = iolib::get_all_queue_informations($base);
        if ($queuesInfo{$job->{'queueName'}}->{execJobsOnFrontal} eq "YES"){
            $hostToConnectViaSSH = $deploy_hostname;
        }
        #deploy part
        my $OAR_NB_NODES = $#hosts + 1;
        my @passinfo=getpwnam($lusr);
        my $shell=$passinfo[8];
        my $cmd = "ssh -t $hostToConnectViaSSH \"sh -c \\\"TTY=\\\\\\\$(tty) && test -e \\\\\\\$TTY && sudo chown $lusr:oar \\\\\\\$TTY && sudo chmod 660 \\\\\\\$TTY \\\" && sudo su - $lusr -c \\\"oarexecuser.sh /tmp/OAR_$connectResa $OAR_NB_NODES $connectResa $lusr $shell $job->{launchingDirectory} I\\\"\"";
        #print("oarsub launchs command : $cmd\n");
        #essential : you become oar instead of the user
        #UID=EUID
        $< = $>;
        print("Connect to OAR reservation $connectResa via the node $hostToConnectViaSSH\n");
        system($cmd);
        print("Disconnect from OAR reservation $connectResa\n");
    }else{
        print("/!\\ You cannot connect to the job $connectResa (maybe you are not the right user OR the job $connectResa is not a reservation OR this job is not Running OR it is not an Interactive connection)\n");
        exit(1);
    }
    exit(0);
}
# End connection to a reservation

# Parse -l options and return an array of hashtables with resources for a moldable job
sub parse_resource_descriptions(@){
    my @resource = shift;
   
    my @result;
    foreach my $r (@resource){
        my %tmp_resources;
        my @comma_split = split(',',$r);
        foreach my $f (@comma_split){
            if ($f =~ /walltime\s*=\s*([\d|:]+)/){
                #walltime part
                my ($w_h,$w_mn,$w_sec) = split(':',$1);
                if (defined($w_h)){
                    if (not defined($w_mn)){
                        $tmp_resources{walltime} = $w_h.":00:00";
                    }elsif (not defined($w_sec)){
                        $tmp_resources{walltime} = $w_h.":00";
                    }else{
                        $tmp_resources{walltime} = $1;
                    }
                }else{
                    die("/!\\I cannot recognize walltime resource value\n");
                }
            }else{
                #hierarchical resource part
                my @slash_split = split('/', $f);
                my @resources_list;
                foreach my $l (@slash_split){
                    if ($l =~ /(\w+)\s*=\s*(\d+)/){
                        push(@resources_list, [$1, $2]);
                    }else{
                        die("/!\\I cannot recognize the resource description : $l\n");
                    }
                }
                $tmp_resources{resources} = \@resources_list;
            }
        }
        push(@result, \%tmp_resources);
    }
    return(@result);
}

@Resource_list = parse_resource_descriptions(@resource);

if ($Interactive == 0) {
    my $exec = $ARGV[0];
    my %scan_result = scan_script($exec) if ($exec ne "");
    if (defined($scan_script{queue}) && !defined($Queue_name)){
        $Queue_name = $scan_script{queue}
    }else{
        warn("/!\\ Ignore script value for queue parameter : $scan_script{queue}; another value was given on the command line.");
    }
    if (defined($scan_script{property}) && !defined($Job_sql_properties)){
        $Job_sql_properties = $scan_script{property}
    }else{
        warn("/!\\ Ignore script value for property parameter : $scan_script{property}; another value was given on the command line.");
    }

    if (!($exec =~ m/^\/.+$/m)){
        # WARNING: we are not the real user, we are oar user!!!
        # so $exec properties are not correct
        if ( -e "$exec" ){
            $exec = $ENV{PWD}."/".$exec ;
        }
    }

    $Cmd_executor = "Qsub";

    my $server;
    my $serveur_port;
    if ($Reservation ne "0"){
        ($server, $serveur_port) = init_tcp_server();
    }

    $Job_id = iolib::add_micheline_job($base, "PASSIVE", \@Resource_list, $exec, "$Host:$server_port", $Queue_name, $Job_sql_properties, $Reservation, defined ($idFile)?$idFile:"NULL", $Checkpoint);
    print("IdJob = $Job_id \n");
}else{
    $Cmd_executor = "Qsub -I";
    my ($server, $serveur_port) = init_tcp_server();

    $Job_id = iolib::add_micheline_job($base, "INTERACTIVE", \@Resource_list, "", "$Host:$serveur_port", $Queue_name, $Job_sql_properties, $Reservation, defined ($idFile)?$idFile:"NULL", $Checkpoint);
    print("IdJob = $Job_id \n");
}

iolib::disconnect($base);

if ($Job_id < 0){
    print("Error in oarsub, verify your syntax or call administrator\n");
    exit(2);
}

#Signal Almigthy

if (defined(oar_Tools::notifyAlmighty($remote_host,$remote_port,"$Cmd_executor"))){
    qdel(1);
    warn("Cannot connect to executor $remote_host:$remote_port so I kill this job. Is OAR started?\n");
    exit(0);
}

my $answer;
if ($Reservation ne "0"){
    #Reservation mode
    print("Reservation mode : waiting validation\n");
    my $client = $server->accept();
    $answer = <$client>;
    if ($answer eq "GOOD RESERVATION\n"){
        print("Reservation valid --> OK\n");
    }else{
        print("Reservation not valid --> KO\n");
    }
}elsif ($Interactive==1) {
    #Interactive mode
    print("Interactive mode : waiting \n");
    my $client = $server->accept();
    $answer = <$client>;
    if ($answer eq "GOOD JOB\n"){
        my $pid=0;
        $pid=fork;
        if($pid == 0){
            #CHILD
            #Pid process registered by bipbip.pl
            $ENV{PATH}="/bin:/usr/bin:/usr/local/bin";
            $ENV{IFS}="";
            $ENV{ENV}="";
            $ENV{USER}="oar";
            $ENV{USERNAME}="oar";
            $ENV{LOGNAME}="oar";
            exec("$binpath/bipbip $Job_id");
        }
        wait;
        my $exit_value  = $? >> 8;
        exit($exit_value);
    }else{
        print("Sorry but the system returned : $answer\n");
    }
}

exit 0;
