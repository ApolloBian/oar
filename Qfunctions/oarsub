#!/usr/bin/perl
# $Id$
#Sumbit job for execution

use strict;
use IO::Socket::INET;
use DBI();
use POSIX qw(strftime);
use Data::Dumper;
use Sys::Hostname;
use Getopt::Long;
use File::Basename;
use oar_iolib;
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use File::Temp qw/ tempfile /;
use oar_Tools;
use oarversion;

select(STDOUT);
$| = 1;

#Try to load XML module
my $XML_enabled = 1;
unless (eval "use XML::Simple qw(XMLout);1"){
    $XML_enabled = 0;
}

#Try to load YAML module
my $YAML_enabled = 1;
unless (eval "use YAML;1"){
    $YAML_enabled = 0;
}

# suitable Data::Dumper configuration for serialization
$Data::Dumper::Purity = 1;
$Data::Dumper::Terse = 1;
$Data::Dumper::Indent = 0;
$Data::Dumper::Deepcopy = 1;


#For interactive
my $remote_host;
my $remote_port;
my $Deploy_hostname;
my $Cosystem_hostname;
my $Cpuset_field;
my $Host = hostname ;

my $base;
my $Server;
my $Job_id;
my $Interactive = 0;
my $Reservation = "0";
my $Default_resources;
my $connect_job ;
my $Scan_script;
my @resource;
my $Queue_name;
my $Job_sql_properties = "";
my $Cmd_executor;
my $stagein = undef;
my $idFile = undef;
my $md5sum = undef;
my $stageindir;
my $sos;
my $Checkpoint=0;
my $notify;
my $job_name;
my $job_env;
my $job_hold;
my $Directory = $ENV{PWD};
my @Type;
my @Anterior_job;
my $Checkpoint_signal = 12; # SIGUSR2
my $Stdout_file;
my $Stderr_file;
my $Resubmit;
my $Cpuset_name;
my $Project = "default";
my $XML_mode;
my $YAML_mode;
my $DUMPER_mode;
my $use_job_key;
my $job_key_priv = "";
my $job_key_pub = "";
my $import_job_key_file = "";
my $job_key_file = "OAR.%jobid%.key";
my $gen_job_key_file = oar_Tools::get_default_oarexec_directory()."/.OAR.jobkey.oarsub_$$";

#to catch ^C signal
$SIG{INT} = 'qdel';
$SIG{HUP} = 'qdel';

# to address ^C in interactive submission
sub qdel($) {
    my $Al_dead = shift;
    
    if (defined($Job_id)) {
        if ($Al_dead eq "INT" ) {
            print(STDERR "\n\nCaught Interrupt (^C),");
        }
        warn("Deleting the job $Job_id ...\n");
        my $base = iolib::connect();
        iolib::lock_table($base,["frag_jobs","event_logs","jobs"]);
        my $err = iolib::frag_job($base,$Job_id);
        iolib::unlock_table($base);
        iolib::disconnect($base);
        warn("Job deleted\n");
        #Signal Almigthy
        oar_Tools::notify_tcp_socket($remote_host,$remote_port,"Qdel");
        exit(1);
    }
}

#Used when we must have a response from the server
sub init_tcp_server(){
    my $server = IO::Socket::INET->new( Type => SOCK_STREAM,
                                        Reuse => 1,
                                        Listen => 1
                                      ) or die("/!\\ Cannot initialize a TCP socket server.\n");
    my $server_port = $server->sockport();

    return($server,$server_port);
}

#Read user script and extract OAR submition options
sub scan_script($){
    my $file = shift;

    my %result;
    
    ($file) = split(" ",$file);
    #my $lusr= getpwuid($ENV{SUDO_UID});
    #open(FILE, "sudo -u $lusr cat $file 2> /dev/null|") or return(%result);
    
    if (open(FILE, $file)){
        if (<FILE> =~ /^#/){
            while (<FILE>) {
                if ( /^#OAR\s+/ ){
                    my $line = $_;
                    if ($line =~ m/^#OAR\s+(-l|--resource)\s*(.+)\s*$/m){
                        push(@{$result{resources}}, $2);
                    }elsif ($line =~ m/^#OAR\s+(-q|--queue)\s*(.+)\s*$/m) {
                        $result{queue} = $2;
                    }elsif ($line =~ m/^#OAR\s+(-p|--property)\s*"(.+)"\s*$/m) {
                        $result{property} = $2;
                    }
                }
            }
        }
        close(FILE);
    }else{
        warn("[ERROR] Cannot open the file $file. Check if it is readable by everybody (744).\n");
        exit(12);
    }

    return(%result);
}

# Connect to a job and give the shell of the user on te remote host
sub connect_job($$$){
    my $job_id = shift;
    my $stop_oarexec = shift;
    my $openssh_cmd = shift;
    
    my $dbh = iolib::connect_ro();
    my $lusr= getpwuid($ENV{SUDO_UID});
    my $job = iolib::get_job($dbh, $job_id);
    if ((($lusr eq $job->{job_user}) or ($lusr eq "oar")) && ($job->{state} eq "Running")) {
        my @hosts = iolib::get_job_current_hostnames($dbh,$job_id);
        my $host_to_connect_via_ssh = $hosts[0];
        #deploy, cosystem and no host part
        my $types = iolib::get_current_job_types($dbh,$job_id);
        if ((defined($types->{cosystem})) or ($#hosts < 0)){
            $host_to_connect_via_ssh = $Cosystem_hostname;
        }elsif (defined($types->{deploy})){
            $host_to_connect_via_ssh = $Deploy_hostname;
        }
        #deploy, cosystem and no host part
        if ((defined($Cpuset_field) and (!defined($types->{cosystem})) and (!defined($types->{deploy})) and ($#hosts >= 0))){
            $ENV{OAR_CPUSET} = iolib::get_job_cpuset_name($dbh,$job_id);
        }else{
            $ENV{OAR_CPUSET} = "";
        }
        my $moldable = iolib::get_current_moldable_job($dbh,$job->{assigned_moldable_job});
        iolib::disconnect($dbh);
        my @passinfo = getpwnam($lusr) or die("Cannot retrive system informations for user $lusr\n");
        my $shell=$passinfo[8];
        $ENV{DISPLAY} = "" if (! -x "/usr/bin/X11/xauth");
        if ($ENV{DISPLAY} ne ""){
            print("Initialize X11 forwarding...\n");
            # first, get rid of remaining unused .Xautority.{pid} files...
            system({"bash"} "bash","-c",'for f in $HOME/.Xauthority.*; do [ -e "/proc/${f#$HOME/.Xauthority.}" ] || rm -f $f; done');
            $ENV{XAUTHORITY} = $ENV{HOME}."/.Xauthority.$$";
            system({"bash"} "bash","-c",'[ -x "/usr/bin/X11/xauth" ] && sudo -H -u "'.$lusr.'" bash -c "unset XAUTHORITY; xauth extract - ${DISPLAY#localhost}" | xauth -q merge - 2> /dev/null');
        }
        my $node_file = oar_Tools::get_default_oarexec_directory()."/$job_id";
        my $res_file = oar_Tools::get_default_oarexec_directory()."/$job_id"."_resources";
        my $oarsub_pids = oar_Tools::get_oarsub_connections_file_name($job_id);
        my $str = oar_Tools::get_oarexecuser_script_for_oarsub($node_file,$job_id,$lusr,$shell,$job->{launching_directory},$res_file,$job->{job_name},$job->{project},iolib::duration_to_sql($moldable->{moldable_walltime}), $moldable->{moldable_walltime}, $job->{job_env});
        my ($cmd_name,@cmd_opts) = split(" ",$openssh_cmd);
        my @cmd;
        my $i = 0;
        $cmd[$i] = $cmd_name;$i++;
        foreach my $p (@cmd_opts){
            $cmd[$i] = $p;$i++;
        }
        if ($ENV{OAR_CPUSET} ne ""){
            $cmd[$i] = "-oSendEnv=OAR_CPUSET";
            $i++;
        }
        if ($ENV{DISPLAY} ne ""){
            $cmd[$i] = "-X";
        }else{
            $cmd[$i] = "-x";
        }
        $i++;
        $cmd[$i] = "-t";$i++;
        $cmd[$i] = $host_to_connect_via_ssh;$i++;
        $str =~ s/\n//g;
        if ($ENV{DISPLAY} ne ""){
            $cmd[$i] = "bash -c 'echo \$PPID >> $oarsub_pids && (which xauth > /dev/null && xauth -q extract - \${DISPLAY#localhost} | sudo -H -u $lusr xauth merge -); TTY=\$(tty) && test -e \$TTY && sudo chown $lusr:oar \$TTY && sudo chmod 660 \$TTY' && sudo -H -u $lusr bash --noprofile --norc -c '$str'";$i++;
        }else{
            $cmd[$i] = "bash -c 'echo \$PPID >> $oarsub_pids && TTY=\$(tty) && test -e \$TTY && sudo chown $lusr:oar \$TTY && sudo chmod 660 \$TTY' && sudo -H -u $lusr bash --noprofile --norc -c '$str'";$i++;
        }
        #print("oarsub launchs command : @cmd\n");
        #essential : you become oar instead of the user
        #UID=EUID
        $< = $>;
        print("Connect to OAR job $job_id via the node $host_to_connect_via_ssh\n");
        system({$cmd[0]} @cmd);
        my $exit_value = $? >> 8;
        if ($exit_value == 2){
            warn("[ERROR] Cannot go into the working directory : $job->{launching_directory}\n");
        }elsif($exit_value != 0){
            warn("[ERROR] An unknown error occured : $?\n");
        }
        if ($stop_oarexec > 0){
            oar_Tools::signal_oarexec($host_to_connect_via_ssh, $job_id, "USR1", 0, undef, $openssh_cmd);
        }
        print("Disconnected from OAR job $job_id\n");
    }else{
        if ($job->{state} ne "Running"){
            warn("/!\\ ERROR : the job $job_id is not running. Its current state is $job->{state}.\n");
        }
        if (($lusr ne $job->{job_user}) and ($lusr ne "oar")){
            warn("/!\\ ERROR : you are not the right user for the job $job_id. This job is owned by $job->{job_user}.\n");
        }
        iolib::disconnect($dbh);
        return(20);
    }
    return(0);
}

#Print help message
sub usage() {
    print <<EOS;
Usage: $0 [options] [-I|-C|<script>]
Submit a job the OAR batch scheduler
Options are:
 -I, --interactive             Request an interactive job. Open a login shell
                               on the first node of the reservation instead of
                               running a script.
 -C, --connect=<job id>        Connect to a running job
 -l, --resource=<list>         Set the requested resources for the job.
                               The different parameters are resource properties
                               registered in OAR database, and `walltime' which
                               specifies the duration before the job must be 
                               automatically terminated if still running.
                               Walltime format is [hour:mn:sec|hour:mn|hour].
                               Ex: nodes=4/cpu=1,walltime=2:00:00
 -S, --scanscript              Batch mode only: asks oarsub to scan the given
                               script for OAR directives (#OAR -l ...)
 -q, --queue=<queue>           Set the the queue to submit the job to
 -p, --property="<list>"       Add constraints to properties for the job.
                               (format is a WHERE clause from the SQL syntax)
 -r, --reservation=<date>      Request a job start time reservation, 
                               instead of a submission. 
     --checkpoint=<delay>      Enable the checkpointing for the job. A signal 
                               is sent DELAY seconds before the walltime on
                               the first processus of the job 
     --signal=<#sig>           Specify the signal to use when checkpointing
                               Use signal numbers, default is 12 (SIGUSR2)
 -t, --type=<type>             Specify a specific type (deploy, besteffort,
                               cosystem, checkpoint, timesharing)
 -d, --directory=<dir>         Specify the directory where to launch the
                               command (default is current directory)
     --project=<txt>           Specify a name of a project the job belongs to
 -n, --name=<txt>              Specify an arbitrary name for the job
 -e, --env=<txt>               Environment variables to set on the running
                               proccess in the form "A=b C=d" (not implemented)
 -a, --anterior=<job id>       Anterior job that must be terminated to start
                               this new one
     --notify=<txt>            Specify a notification method
                               (mail or command to execute). Ex: 
                                   --notify "mail:name\@domain.com"
                                   --notify "exec:/path/to/script args"
     --resubmit=<job id>       Resubmit the given job as a new one
     --force-cpuset-name=<txt> Specify a cpuset name to use instead of the job
                               id (WARNING: if several jobs have the same
                               cpuset name then processes of a job could be
                               killed when another one finishes on the same
                               computer)
 -k, --use-job-key             Activate the job-key mechanism. A job-key will
                               be generated allowing to connect the job from
                               outside the set of resources managed by OAR.
 -i, --import-job-key-from-file=<file>
                               Import the job-key to use from existing files
                               (public and private key files) instead of
                               generating a new one
     --import-job-key-inline-priv=<txt>
     --import-job-key-inline-pub=<txt>
                               Import the job-key to use passing both the
                               public and the private parts in the command
                               line instead of generating a new one
     --job-key-file=<file>     Specify the prefix of the files that will store
                               the job-key for the job.
                               (the %jobid% pattern is automatically replaced)
     --stdout-file=<file>      Specify the file that will store the standart
                               output stream of the job.
                               (the %jobid% pattern is automatically replaced)
     --stderr-file=<file>      Specify the file that will store the standart
                               error stream of the job.
                               (the %jobid% pattern is automatically replaced)
     --hold                    Set the job state into Hold instead of Waiting,
                               so that it is not scheduled (you must run
                               "oarresume" to turn it into the Waiting state)
 -s, --stagein=<dir|tgz>       Set the stagein directory or archive
     --stagein-md5sum=<md5sum> Set the stagein file md5sum
 -D, --dumper                  Print result in DUMPER format
 -X, --xml                     Print result in XML format
 -Y, --yaml                    Print result in YAML format
 -h, --help                    Print this help message
 -v, --version                 Print OAR version number
EOS
}

# manage the job key is option is activated
# read job key file if import from file 
# generate a job key if no import.
# function must exit with $job_key_priv and $job_key_pub set if $use_job_key is set.
sub job_key_management() {
		if (defined ($use_job_key) and !($job_key_priv ne "") and !($job_key_priv ne "") and !($import_job_key_file ne "") and defined($ENV{OAR_JOB_KEY_FILE}))
        $import_job_key_file=$ENV{OAR_JOB_KEY_FILE};
    if ((!defined($use_job_key)) and (($job_key_priv ne "") or ($job_key_pub ne "") or ($import_job_key_file ne "") or ($job_key_file ne ""))){
        warn("Error: You must use the --use-job-key (or -k switch) prior to use other job key related options.\n");
        exit(15);
    }
    if (defined($use_job_key)){
        if (defined($Cpuset_name)){
            warn("Error: Cannot set a cpuset name when using a job key.\n");
            exit(15);
        }
        if ((!($job_key_priv ne "") or ($job_key_pub ne "")) and (!($job_key_pub ne "") or ($job_key_priv ne ""))){
            warn("Error: In order to import the job-key inline, you must give both the public and private parts using both of the related command line options.\n");
            exit(15);
        }
        if ((($job_key_priv ne "") or ($job_key_pub ne "")) and ($import_job_key_file ne "")){
            warn("Error: You cannot use both the inline and file import method at the same time for the job-key.\n");
            exit(15);
        }
        if ($import_job_key_file ne ""){
            my $lusr= getpwuid($ENV{SUDO_UID});
            # Test files with user privileges
            system({"bash"} "bash","-c",'sudo -u '.$lusr.' bash -c \'[ -r "'.$import_job_key_file.'" -a -r "'.$import_job_key_file.'.pub" ]\'');
            if ($? != 0){
                warn ("Error: Cannot read one or both of the files to import the job-key: $import_job_key_file and $import_job_key_file.pub.\n");
                exit(14);
            }
            # read private and public key files: sudo -u user needed in order to be able to read the file for sure
            # safer way to do a `cmd`, see perl cookbook 
            my $pid;
            die "cannot fork: $!" unless defined ($pid = open(SAFE_CHILD, "-|"));
            if ($pid == 0) {
                unless (exec("bash","-c",'sudo -u "'.$lusr.'" cat "'.$import_job_key_file.'"')) {
                    warn ("Error: Cannot exec bash shell");
                    exit(14);
                }
            }else{
                my @tmp_key;
                while (<SAFE_CHILD>) {
                    push @tmp_key, $_;
                }
                $job_key_priv = join "",@tmp_key;
                close(SAFE_CHILD);                 # $? contains status
                if ($? != 0) {
                    warn ("Error: Cannot read the private part of your job key: $import_job_key_file.\n");
                    exit(14);
                }
            }
        
            die "cannot fork: $!" unless defined ($pid = open(SAFE_CHILD, "-|"));
            if ($pid == 0) {
                unless (exec("bash","-c",'sudo -u "'.$lusr.'" cat "'.$import_job_key_file.'.pub"')) {
                    warn ("Error: Cannot exec bash shell");
       	            exit(14);
      	        }
            }else{
                my @tmp_key;
                while (<SAFE_CHILD>) {
                    push @tmp_key, $_;
                }
                $job_key_pub = join "",@tmp_key;
                close(SAFE_CHILD);                 # $? contains status
                if ($? != 0) {
                    warn ("Error: Cannot read the public part of your job key: $import_job_key_file.pub.\n");
                    exit(14);
                } 
            }
        }
        if (($job_key_priv eq "") and ($job_key_pub eq "")) {
            # we must generate the ssh key
            print("Generating public/private job key pair...\n");
            # ssh-keygen: no passphrase, smallest key (1024 bits), ssh2 rsa faster than dsa.
            if (system({"bash"} "bash","-c",'ssh-keygen -b 1024 -C "Job key created by OAR" -N "" -t rsa -f "'.$gen_job_key_file.'" > /dev/null')) {
                warn ("Error: Job key generation failed ($?).\n");
                exit(14);
            }
            # The key was automatically generated and oar own it
            if (!(-r $gen_job_key_file and -r $gen_job_key_file.".pub")){
                warn ("Error: Cannot read one or both of the files generated for the job key: $gen_job_key_file and $gen_job_key_file.pub.\n");
                exit(14);
            }
            if (open(PRIVKEY, "$gen_job_key_file")){
                while ($_ = <PRIVKEY>){
                    $job_key_priv .= $_;
                }
                close(PRIVKEY);
            }else{
                warn ("Error: Cannot read the private part of your job key: $gen_job_key_file.\n");
                exit(14);
            }
            if (open(PUBKEY, "$gen_job_key_file.pub")){
                while ($_ = <PUBKEY>){
                    $job_key_pub .= $_;
                }
                close(PUBKEY);
            }else{
                warn ("Error: Cannot read the public part of your job key: $gen_job_key_file.pub.\n");
                exit(14);
            }
        }
    }
    
    # last checks
    if (defined($use_job_key)){
        if ($job_key_pub eq "") {
            warn("Error: missing job public key (private key found).\n");
            exit(15);
        } 
        if ($job_key_priv eq "") {
            warn("Error: missing job private key (public key found).\n");
            exit(15);
        } 
        if ($job_key_priv !~ /^(ssh-rsa|ssh-dss)\s.+\n*$/){
            warn("Error: Bad job key format. The public key must begin with either `ssh-rsa' or `ssh-dss' and is only 1 line.\n");
            exit(14);
        }
        $job_pub_key =~ s/\n//g;
    }
}

# Parse -l options and return an array of hashtables with resources for a moldable job
sub parse_resource_descriptions($){
    my $resource_ref = shift;
    
    my @resource= @{$resource_ref};
    if ($#resource < 0){
        push(@resource,$Default_resources);
    }
    #print "--@resource--\n";

    my @result;
    foreach my $r (@resource){
        my @resource_groups;
        my $end_loop = 0;
        while ($end_loop == 0){
            my $initial_resource = $r;
            my %tmp_result;
            if ($r =~ /^\s*(\++|\,+|\s*)\s*\{(.+?)}(.*)$/){
                # $1 = property string
                $tmp_result{property} = $2;
                $r = $3;
            }
            
            my $resources_to_parse;
            if (($r =~ /^\s*(\++|\,+|\s*)\s*[\/]*([^\,\+]+)\s*(.*)$/) and ($2 !~ /^\s*walltime/)){
                $resources_to_parse = $2;
                $r = $3;
            }else{
                $Default_resources =~ /^\s*[\/]*(.+)$/;
                # Remove first /
                $resources_to_parse = $1;
            }
            my @slash_split = split('\/', $resources_to_parse);
            my @resources_list;
            foreach my $l (@slash_split){
                if ($l =~ /(\w+)\s*=\s*(\d+)/){
                    my $tmp = $1;
                    $tmp = "network_address" if ($tmp eq "nodes");
                    push(@resources_list, { resource => $tmp, value => $2 });
                }elsif ($l =~ /(\w+)\s*=\s*ALL/){
                    my $tmp = $1;
                    $tmp = "network_address" if ($tmp eq "nodes");
                    push(@resources_list, { resource => $tmp, value => -1 });
                }elsif ($l =~ /(\w+)\s*=\s*BEST/){
                    my $tmp = $1;
                    $tmp = "network_address" if ($tmp eq "nodes");
                    push(@resources_list, { resource => $tmp, value => -2 });
                }else{
                    die("/!\\ Cannot recognize the resource description : $l\n");
                }
            }
            $tmp_result{resources} = \@resources_list;
            
            if ($r =~ /^[\s\,]*walltime\s*=\s*([\d|:]+)\s*(\,.+|\s*)$/){
                #walltime part
                my ($w_h,$w_mn,$w_sec) = split(':',$1);
                if (defined($w_h)){
                    if (not defined($w_mn)){
                        $resource_groups[1] = "$w_h:00:00";
                    }elsif (not defined($w_sec)){
                        $resource_groups[1] = "$w_h:$w_mn:00";
                    }else{
                        $resource_groups[1] = "$w_h:$w_mn:$w_sec";
                    }
                    $resource_groups[1] = iolib::sql_to_duration("$resource_groups[1]");
                }else{
                    die("/!\\ Cannot recognize walltime resource value\n");
                }
                $r = $2;
            }
            if ($r eq $initial_resource){
                die("/!\\ Cannot recognize -- $r -- resource\n");
            }
            push(@{$resource_groups[0]}, \%tmp_result);

            if ($r =~ /^\s*$/){
                $end_loop = 1;
            }
        }
        push(@result, \@resource_groups);
    }
    return(@result);
}

#
# Main
#

init_conf($ENV{OARCONFFILE});
$remote_host = get_conf("SERVER_HOSTNAME");
$remote_port = get_conf("SERVER_PORT");
$stageindir = get_conf("STAGEIN_DIR");

$Default_resources = get_conf("OARSUB_DEFAULT_RESOURCES");
if (!defined($Default_resources)){
    $Default_resources = "/resource_id=1";
}

$Deploy_hostname = get_conf("DEPLOY_HOSTNAME");
if (!defined($Deploy_hostname)){
    $Deploy_hostname = $remote_host;
}

$Cosystem_hostname = get_conf("COSYSTEM_HOSTNAME");
if (!defined($Cosystem_hostname)){
    $Cosystem_hostname = $remote_host;
}

$Cpuset_field = get_conf("CPUSET_RESOURCE_PROPERTY_DB_FIELD");

if (is_conf("OAR_RUNTIME_DIRECTORY")){
    oar_Tools::set_default_oarexec_directory(get_conf("OAR_RUNTIME_DIRECTORY"));
}
my $default_oar_dir = oar_Tools::get_default_oarexec_directory();
if (!(((-d $default_oar_dir) and (-O $default_oar_dir)) or (mkdir($default_oar_dir)))){
    die("ERROR: Cannot create the OAR directory $default_oar_dir or bad permissions.\n");
}

my $binpath;
if (defined($ENV{OARDIR})){
    $binpath = $ENV{OARDIR}."/";
}else{
    die("ERROR: OARDIR env variable must be defined.\n");
}

my $Openssh_cmd = get_conf("OPENSSH_CMD");
$Openssh_cmd = oar_Tools::get_default_openssh_cmd() if (!defined($Openssh_cmd));

Getopt::Long::Configure ("gnu_getopt");
my $Version;
GetOptions ("resource|l=s" => \@resource,
            "queue|q=s"   => \$Queue_name,
            "interactive|I"  => \$Interactive,
            "property|p=s" => \$Job_sql_properties,
            "reservation|r=s" => \$Reservation,
            "connect|C=i" => \$connect_job,
            "stagein|s=s" => \$stagein,
            "stagein-md5sum=s" => \$md5sum,
            "checkpoint=i" => \$Checkpoint,
            "help|h" => \$sos,
            "notify=s" => \$notify,
            "type|t=s" => \@Type,
            "directory|d=s" => \$Directory,
            "name|n=s" => \$job_name,
            "project=s" => \$Project,
            "env|e=s" => \$job_env,
            "hold" => \$job_hold,
            "anterior|a=i" => \@Anterior_job,
            "signal=i" => \$Checkpoint_signal,
            "stdout=s" => \$Stdout_file,
            "stdout-file=s" => \$Stdout_file,
            "stderr=s" => \$Stderr_file,
            "stderr-file=s" => \$Stderr_file,
            "resubmit=i" => \$Resubmit,
            "force-cpuset-name=s" => \$Cpuset_name,
            "scanscript|S" => \$Scan_script,
            "xml|X" => \$XML_mode,
            "yaml|Y" => \$YAML_mode,
            "dumper|D" => \$DUMPER_mode,
            "use-job-key|k" => \$use_job_key,
            "import-job-key-inline-priv=s" => \$job_key_priv,
            "import-job-key-inline-pub=s" => \$job_key_pub,
            "import-job-key-from-file|i=s" => \$imported_job_key_file,
            "job-key-file=s" => \$job_key_file,
            "version|v" => \$Version
           );


if (defined($Version)){
    print("OAR version : ".oarversion::get_version()."\n");
    exit(0);
}

if (defined($sos)){
    usage();
    exit(0);
}

# Check the default name of the key if we have to generate it
if (is_conf("OARSUB_FORCE_JOB_KEY")){
    if (lc(get_conf("OARSUB_FORCE_JOB_KEY")) eq "yes")
        $use_job_key = 1;
}

$base = iolib::connect();

if (defined($Resubmit)){
    print("Resubmitting job $Resubmit ...");
    my $err = iolib::resubmit_job($base,$Resubmit);
    if ($err > 0){
        $Job_id = $err;
        print("DONE\n");
        print("OAR_JOB_ID=$Job_id\n");
        if (defined(oar_Tools::notify_tcp_socket($remote_host,$remote_port,"Qsub"))){
            warn("Cannot connect to executor $remote_host:$remote_port. Is OAR started?\n");
            exit(3);
        }
        exit(0);
    }else{
        print("ERROR\n");
        if ($err == -1){
            warn("/!\\ An interactive job or a reservation cannot be resubmitted\n");
        }elsif ($err == -2){
            warn("/!\\ The job must be in Error or Terminated state\n");
        }elsif ($err == -3){
            warn("/!\\ You are not the right user\n");
        }elsif ($err == -4){
            warn("/!\\ Another active job is using the same ssh keys\n");
        }else{
            warn("/!\\ Unknown error\n");
        }
        exit(4);
    }
}

if ((@ARGV != 1) && ($Interactive == 0) && ($Reservation eq "0") && (!defined($connect_job))){
    usage();
    exit(5);
}

if (($Interactive == 1) and ($Reservation ne "0")){
    warn("/!\\ A reservation cannot be interactive.\n");
    usage();
    exit(6);
}

# stagein machinery
if (defined $stagein) {
    print "Setting up stagein...\n";
    if (-d $stagein) {
        print "Archiving the content of the directory \"$stagein\" for the job stagein...\n";
        my  (undef, $filename) = tempfile (SUFFIX=>".oar-stagein.tgz",OPEN => 0);
        system "tar cfz $filename $stagein" and die "Failed to archive the directory: $?\n";
        print "Stagein archive = $filename\n";
        print "(You may save this file if you plan to submit other jobs later with the same stagein)\n";
        $stagein = $filename;
        $md5sum = undef;
    }
    ( -r $stagein ) or die "Stagein file not found: $stagein\n";
    unless (defined $md5sum) {
        print "Computing stagein md5sum...\n";
        ($md5sum) = split(" ",`md5sum $stagein`);
        print "md5sum = $md5sum\n";
        print "(You may use the -m option with this md5sum for other job submitions with the same stagein)\n";
    }
    $base = iolib::connect();
    iolib::get_lock($base,$md5sum,3600) or die "Failed to lock stagein\n";
    $idFile = iolib::get_stagein_id($base,$md5sum);
    if (defined $idFile) {
        print "This stagein is already stored on the server.\n";
    } else {
        my $location = "$stageindir/$md5sum";
        my $method = "FILE";
        my $compression = "tar.gz";
        print "Uploading stagein...\n";
        system "scp $stagein $location" and die "Stagein upload failed\n";
        my @stats = stat $stagein;
        $idFile=iolib::set_stagein($base,$md5sum,$location,$method,$compression,$stats[7]);
        defined $idFile or die "Failed to setup stagein\n";
    }
    iolib::release_lock($base,$md5sum) or die "Failed to unlock stagein\n";
    iolib::disconnect($base);
    print "Stagein completed.\n";
}

# Connect to a reservation
if (defined($connect_job)){
    # Do not kill the job if the user close the window
    $SIG{HUP} = 'DEFAULT';
    exit(connect_job($connect_job,0,$Openssh_cmd));
}
# End connection to a reservation

job_key_management();

my $base_ro = iolib::connect_ro();

if (($Interactive == 0) and ($ARGV[0] ne "")) {
    my $exec = $ARGV[0];
    if (defined($Scan_script)){
        my %scan_result = scan_script($exec) if ($exec ne "");
        #print("$Queue_name \n");
        if (defined($scan_result{queue}) && !defined($Queue_name)){
            $Queue_name = $scan_result{queue}
        }elsif(defined($scan_result{queue}) && defined($Queue_name)){
            warn("/!\\ Ignore script value for queue parameter : $scan_result{queue}; another value was given on the command line.");
        }
        if (defined($scan_result{property}) && !defined($Job_sql_properties)){
            $Job_sql_properties = $scan_result{property}
        }elsif(defined($scan_result{property}) && defined($Job_sql_properties)){
            warn("/!\\ Ignore script value for property parameter : $scan_result{property}; another value was given on the command line.");
        }
        if (defined($scan_result{resources})){
            push(@resource, @{$scan_result{resources}});
        }
    }

    my @resource_list = parse_resource_descriptions(\@resource);

    #if (!($exec =~ m/^\/.+$/m)){
        # WARNING: we are not the real user, we are oar user!!!
        # so $exec properties are not correct
    #    if ( -e "$exec" ){
    #        $exec = $Directory."/".$exec ;
    #    }
    #}

    $Cmd_executor = "Qsub";

    my $server_port;
    if ($Reservation ne "0"){
        #Test if this job is a reservation and the syntax is right
        if ($Reservation =~ m/^\s*(\d{4}\-\d{1,2}\-\d{1,2})\s+(\d{1,2}:\d{1,2}:\d{1,2})\s*$/m){
            $Reservation = iolib::sql_to_local("$1 $2");
            print("$Reservation\n");
        }else{
            warn("Syntax error near -r or --reservation option. Reservation date exemple : \"2007-03-25 17:32:12\"\n");
            iolib::disconnect($base);
            exit(7);
        }
        ($Server, $server_port) = init_tcp_server();
    }

    $Job_id = iolib::add_micheline_job($base, $base_ro, "PASSIVE", \@resource_list, $exec, "$Host:$server_port", $Queue_name, $Job_sql_properties, $Reservation, defined ($idFile)?$idFile:"NULL", $Checkpoint, $Checkpoint_signal, $notify, $job_name,$job_env,\@Type, $Directory,\@Anterior_job,$Stdout_file,$Stderr_file,$Cpuset_name,$job_hold,$Project,$job_priv_key,$job_pub_key);
}else{
    if ($ARGV[0] ne ""){
        warn("/!\\ You asked for an Interactive job SO I will ignore arguments: $ARGV[0] ; Is your syntax right?\n");
    }
    $Cmd_executor = "Qsub -I";

    my @resource_list = parse_resource_descriptions(\@resource);
 
    if ($Reservation ne "0"){
        #Test if this job is a reservation and the syntax is right
        if ($Reservation =~ m/^\s*(\d{4}\-\d{1,2}\-\d{1,2})\s+(\d{1,2}:\d{1,2}:\d{1,2})\s*$/m){
            $Reservation = iolib::sql_to_local("$1 $2");
            print("$Reservation\n");
        }else{
            warn("Syntax error near -r or --reservation option. Reservation date exemple : \"2007-03-25 17:32:12\"\n");
            iolib::disconnect($base);
            exit(7);
        }
    }
    
    my $server_port;
    ($Server, $server_port) = init_tcp_server();

    $Job_id = iolib::add_micheline_job($base, $base_ro, "INTERACTIVE", \@resource_list, "", "$Host:$server_port", $Queue_name, $Job_sql_properties, $Reservation, defined ($idFile)?$idFile:"NULL", $Checkpoint, $Checkpoint_signal, $notify, $job_name,$job_env,\@Type, $Directory,\@Anterior_job,$Stdout_file,$Stderr_file,$Cpuset_name,$job_hold,$Project,$job_priv_key,$job_pub_key);
}
print("OAR_JOB_ID=$Job_id\n");

if ((defined($DUMPER_mode)) or (defined($YAML_mode) or ($XML_mode))){
    print("\n##########\n");
    my $tmp = { job_id => $Job_id };
    if (defined($DUMPER_mode)){
        print(Dumper($tmp));
    }elsif(defined($XML_mode)){
        if ($XML_enabled == 1){
            print(XMLout($tmp));
        }else{
            warn("[ERROR] Cannot load XML module.\n");
        }
    }elsif(defined($YAML_mode)){
        if ($YAML_enabled == 1){
            print(YAML::Dump($tmp));
        }else{
            warn("[ERROR] Cannot load YAML module.\n");
        }
    }
    print("\n##########\n\n");
}

iolib::disconnect($base_ro);
iolib::disconnect($base);

if ($Job_id < 0){
    warn("Oarsub failed: please verify your request syntax or ask for support to your admin.\n");
    exit(8);
}

if (defined($use_job_key)){
    # we must copy the keys in the directory specified with the right name
    $job_key_file =~ s/%jobid%/$Job_id/g;
    my $lusr= getpwuid($ENV{SUDO_UID});
    system({"bash"} "bash","-c",'sudo -u '.$lusr.' bash -c \'cat > '.$job_key_file.'\' < '.$gen_job_key_file);
    system({"bash"} "bash","-c",'sudo -u '.$lusr.' bash -c \'cat > '.$job_key_file.'.pub\' < '.$gen_job_key_file.'.pub');
    system({"bash"} "bash","-c",'sudo -u '.$lusr.' bash -c \'chmod 644 '.$job_key_file.'.pub; chmod 600 '.$job_key_file.'\'');
    unlink($gen_job_key_file,$gen_job_key_file.".pub");
    if ($import_job_key_file ne "")
        print("OAR_JOB_KEY_FILE=$import_job_key_file\n");
    else
        print("OAR_JOB_KEY_FILE=$job_key_file\n");
}

#Signal Almigthy
if (defined(oar_Tools::notify_tcp_socket($remote_host,$remote_port,"$Cmd_executor"))){
    #qdel(1);
    warn("Cannot connect to executor $remote_host:$remote_port so I kill this job. Is OAR started?\n");
    exit(9);
}

my $answer;
if ($Reservation ne "0"){
    #Reservation mode
    print("Reservation mode : waiting validation...\n");
    my $client = $Server->accept();
    $answer = <$client>;
    chop($answer);
    if ($answer eq "GOOD RESERVATION"){
        print("Reservation valid --> OK\n");
    }else{
        print("Reservation not valid --> KO ($answer)\n");
        exit(10);
    }
}elsif ($Interactive==1) {
    #Interactive mode
    print("Interactive mode : waiting...\n");
    my $prev_str = "";
    do{
        my $client = $Server->accept();
        $answer = <$client>;
        chop($answer);
        if (($answer ne $prev_str) and ($answer ne "GOOD JOB")){
            print("[".strftime("%F %T",localtime)."] $answer\n");
            $prev_str = $answer;
        }
    }while (($answer ne "GOOD JOB") and ($answer ne "BAD JOB") and ($answer ne "JOB KILLED") and ($answer !~ /^INVALID RESOURCES/));
    print("\n");
    if ($answer eq "GOOD JOB"){
        exit(connect_job($Job_id,1,$Openssh_cmd));
    }else{
        exit(11);
    }
}

exit(0);
