#!/usr/bin/perl

use English;
use oar_iolib;
use Sys::Hostname;
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use IPC::Open2;
use IPC::Open3;
use Data::Dumper;
use oar_Judas qw(oar_debug oar_warn oar_error);
use IO::Socket::INET;
use oar_Tools;


init_conf($ENV{OARCONFFILE});
my $Server_hostname = get_conf("SERVER_HOSTNAME");
my $Server_port = get_conf("SERVER_PORT");

my $Deploy_hostname = get_conf("DEPLOY_HOSTNAME");
if (!defined($Deploy_hostname)){
    $Deploy_hostname = $Server_hostname;
}

my $Server_epilogue = get_conf("SERVER_EPILOGUE_EXEC_FILE");

my $Openssh_cmd = get_conf("OPENSSH_CMD");
$Openssh_cmd = oar_Tools::get_default_openssh_cmd() if (!defined($Openssh_cmd));

# arg1 --> host+pid of bipbip process
# return -1 if the ssh connection timed out, else return the return code of the command kill
#sub killbipbip($){
#    my $hostpid=shift;
#
#    my ($host,$pid)=split /:/, $hostpid;
#    my $cmd = "oarkill $pid";
#    my $res=0;
#    if($host eq hostname ){
#        oar_warn("[Leon] Kill local bipbip with : $cmd\n");
#        #$res=forkexecwait("$cmd");
#        system("$cmd");
#        $res = $? >> 8;
#    }else{
#        oar_warn("[Leon] Kill remote bipbip : go on $host and execute : $cmd\n");
#        eval {
#            $SIG{ALRM} = sub { die "alarm\n" };
#            alarm(oar_Tools::get_ssh_timeout());
#            #$res=forkexecwait("ssh -qx $host \"$cmd\"");
#            system("ssh -x $host \"$cmd\"");
#            $res = $? >> 8;
#            alarm(0);
#        };
#        if ($@){
#            if ($@ eq "alarm\n"){
#                oar_error("[Leon] Killbipbip : ssh timeout $?, on node $host\n");
#                $res=-1;
#            }
#        }
#    }
#    return($res);
#}

my $Exit_code = 0;

my $base = iolib::connect();

#do it for all job in state LEON in the data base table fragJobs
iolib::lock_table($base,["jobs","job_state_logs","resources","assigned_resources","frag_jobs","resource_state_logs","resource_properties","event_logs","moldable_job_descriptions","job_types","job_resource_descriptions","job_resource_groups","challenges","job_dependencies"]);

foreach my $j (iolib::get_to_kill_jobs($base)){
#  if (iolib::is_job_desktopComputing($base,$Jid)) {
#    oar_debug("[Leon] Job $Jid is affected to a DesktopComputing node, I don't handle it\n");
#	} else {
    oar_debug("[Leon] Normal kill : I treate the job $j->{job_id}\n");
    if (($j->{state} eq "Waiting") || ($j->{state} eq "Hold")){
        oar_debug("[Leon] Job is not launched\n");
        iolib::set_job_state($base,$j->{job_id},"Error");
        iolib::set_job_message($base,$j->{job_id},"job killed by Leon directly");
        if ($j->{job_type} eq "INTERACTIVE"){
            oar_debug("[Leon] I notify oarsub in waiting mode\n");
            #answer($Jid,$refJob->{'infoType'},"JOB KILLED");
            my ($addr,$port) = split(/:/,$j->{info_type});
            if (!defined(oar_Tools::notify_tcp_socket($addr, $port, "JOB KILLED"))){
                oar_debug("[Leon] Notification done\n");
            }else{
                oar_debug("[Leon] Cannot open connection to oarsub client for job $j->{job_id}, it is normal if user typed Ctrl-C !!!!!!\n");
            }
        }
        $Exit_code = 1;
    }elsif (($j->{state} eq "Terminated") || ($j->{state} eq "Error") || ($j->{state} eq "Finishing")){
        oar_debug("[Leon] Job is terminated or is terminating I do nothing\n");
    }else{
        my $types = iolib::get_current_job_types($base,$j->{job_id});
        if (defined($types->{cosystem})){
            iolib::set_job_state($base,$j->{job_id},"Terminated");
            iolib::set_finish_date($base,$j->{job_id});
        }
        my @hosts = iolib::get_job_current_hostnames($base,$j->{job_id});
        my $host_to_connect_via_ssh = $hosts[0];
        #deploy part
        if (defined($types->{deploy})){
            $host_to_connect_via_ssh = $Deploy_hostname;
        }
        #deploy part
        if (defined($host_to_connect_via_ssh)){
            iolib::add_new_event($base,"SEND_KILL_JOB",$j->{job_id},"[Leon] Send kill signal to oarexec on $host_to_connect_via_ssh for the job $j->{job_id}");
            oar_Tools::signal_oarexec($host_to_connect_via_ssh, $j->{job_id}, "TERM", 0, $base, $Openssh_cmd);
        }
    }
    iolib::job_arm_leon_timer($base,$j->{job_id});
#  }
}

#I treate jobs in state EXTERMINATED in the table fragJobs
foreach my $j (iolib::get_to_exterminate_jobs($base)){
    #my $bipbippid = $j->{bpid};
    #if (defined($bipbippid) && ($bipbippid ne "")){
    #    my $result_kill_bipbip = 0;
    #    #$result_kill_bipbip = killbipbip($bipbippid);
    #    if ($result_kill_bipbip == -1){
    #        iolib::add_new_event($base,"LEON_KILL_BIPBIP_TIMEOUT",$j->{job_id},"[Leon] kill bipbip with $bipbippid for the job $j->{job_id} and ssh timeouts");
    #    }
    #}

    iolib::set_job_state($base,$j->{job_id},"Finishing");
    if ($j->{start_time} eq "0000-00-00 00:00:00"){
        iolib::set_running_date($base,$j->{job_id});
    }
    iolib::set_finish_date($base,$j->{job_id});
    iolib::set_job_message($base,$j->{job_id},"job exterminated by Leon");
    iolib::job_arm_leon_timer($base,$j->{job_id});
    $Exit_code = 2;

    my $types = iolib::get_current_job_types($base,$j->{job_id});
    if (defined($types->{cosystem})){
        iolib::set_job_state($base,$j->{job_id},"Error");
        iolib::set_finish_date($base,$j->{job_id});
        next;
    }
 
    my $pid = fork();
    if ($pid == 0){
        #CHILD
        undef($base);
        $SIG{USR1} = 'IGNORE';
        $SIG{INT}  = 'IGNORE';
        $SIG{TERM} = 'IGNORE';
        my $str = "[Leon] I exterminate the job $j->{job_id}";
        my $dbh = iolib::connect();
        iolib::job_finishing_sequence($dbh,$Server_epilogue,$Server_hostname,$Server_port,$j->{job_id},undef,"EXTERMINATE_JOB",$str);
        iolib::disconnect($dbh);
        exit(0);
    }
}
iolib::unlock_table($base);

iolib::disconnect($base);

exit($Exit_code);
