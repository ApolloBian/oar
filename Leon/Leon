#!/usr/bin/perl

use English;
use oar_iolib;
use Sys::Hostname;
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use IPC::Open2;
use IPC::Open3;
use Data::Dumper;
use oar_Judas qw(oar_debug oar_warn oar_error);
use IO::Socket::INET;
use oar_Tools;

# timeout for commands executed via ssh
my $timeoutSSH = oar_Tools::getSSHTimeout();

init_conf("oar.conf");
my $server_hostname = get_conf("SERVER_HOSTNAME");

my $deploy_hostname = get_conf("DEPLOY_HOSTNAME");
if (!defined($deploy_hostname)){
    $deploy_hostname = $server_hostname;
}

my $base;

# arg1 --> host+pid of bipbip process
# return -1 if the ssh connection timed out, else return the return code of the command kill
sub killbipbip($){
    my $hostpid=shift;

    my ($host,$pid)=split /:/, $hostpid;
    my $cmd = "oarkill $pid";
    my $res=0;
    if($host eq hostname ){
        oar_warn("[Leon] Kill local bipbip with : $cmd\n");
        #$res=forkexecwait("$cmd");
        system("$cmd");
        $res = $? >> 8;
    }else{
        oar_warn("[Leon] Kill remote bipbip : go on $host and execute : $cmd\n");
        eval {
            $SIG{ALRM} = sub { die "alarm\n" };
            alarm($timeoutSSH);
            #$res=forkexecwait("ssh -qx $host \"$cmd\"");
            system("ssh -qx $host \"$cmd\"");
            $res = $? >> 8;
            alarm(0);
        };
        if ($@){
            if ($@ eq "alarm\n"){
                oar_error("[Leon] Killbipbip : ssh timeout $?, on node $host\n");
                $res=-1;
            }
        }
    }
    return($res);
}

my $Jid=0;
my $exitCode = 0;

$base = iolib::connect();

my $tmp = iolib::get_job($base,$Jid);
my $user = $tmp->{job_user};
my $usercmd = $tmp->{command};

#do it for all job in state LEON in the data base table fragJobs
iolib::lock_table($base,["jobs","job_state_logs","resources","assigned_resources","frag_jobs","resource_state_logs","resource_properties","event_logs","moldable_job_descriptions","job_types","job_resource_descriptions","job_resource_groups","challenges","job_dependencies"]);
my @JobToFrag = iolib::get_tokill_job($base);
while(scalar(@JobToFrag)){
    $Jid=shift(@JobToFrag);
#  if (iolib::is_job_desktopComputing($base,$Jid)) {
#    oar_debug("[Leon] Job $Jid is affected to a DesktopComputing node, I don't handle it\n");
#	} else {
    oar_debug("[Leon] Normal kill : I treate the job $Jid\n");
    my $refJob = iolib::get_job($base,$Jid);
    if (($refJob->{'state'} eq "Waiting") || ($refJob->{'state'} eq "Hold")){
        oar_debug("[Leon] Job is not launched\n");
        iolib::set_job_state($base,$Jid,"Error");
        iolib::set_job_message($base,$Jid,"job killed by Leon directly");
        if ($refJob->{'job_type'} eq "INTERACTIVE"){
            oar_debug("[Leon] I notify oarsub in waiting mode\n");
            #answer($Jid,$refJob->{'infoType'},"JOB KILLED");
            my ($addr,$port) = split(/:/,$refJob->{'info_type'});
            if (!defined(oar_Tools::notifyTCPSocket($addr, $port, "JOB KILLED"))){
                oar_debug("[Leon] Notification done\n");
            }else{
                oar_debug("[Leon] Cannot open connection to oarsub client for job $Jid, it is normal if user typed Ctrl-C !!!!!!\n");
            }
        }
        $exitCode = 1;
    }elsif (($refJob->{'state'} eq "Terminated") || ($refJob->{'state'} eq "Error")){
        oar_debug("[Leon] Job is terminated, I do nothing\n");
    }else{
        my @hosts = iolib::get_job_current_hostnames($base,$Jid);
        my $hostToConnectViaSSH = $hosts[0];
        #deploy part
        if ($refJob->{deploy_feature} eq "YES"){
        #if ($refJob->{'queueName'} eq "deploy"){
            $hostToConnectViaSSH = $deploy_hostname;
        }
        #deploy part
        if (defined($hostToConnectViaSSH)){
            iolib::add_new_event($base,"SEND_KILL_JOB",$Jid,"[Leon] Send kill signal to oarexec on $hostToConnectViaSSH for the job $Jid");
            oar_Tools::signalOarexec($hostToConnectViaSSH, $Jid, "TERM", 0);
        }
    }
    iolib::job_arm_leon_timer($base,$Jid);
#  }
}

#I treate jobs in state EXTERMINATED in the table fragJobs
my @JobToFrag = iolib::get_toexterminate_job($base);
while(scalar(@JobToFrag)){
    $Jid = shift(@JobToFrag);
    my $refJob = iolib::get_job($base,$Jid);

    my $bipbippid = $refJob->{bpid};
    if (defined($bipbippid) && ($bipbippid ne "")){
        my $resultKillBipbip = 0;
        $resultKillBipbip = killbipbip($bipbippid);
        if ($resultKillBipbip == -1){
            iolib::add_new_event($base,"LEON_KILL_BIPBIP_TIMEOUT",$Jid,"[Leon] kill bipbip with $bipbippid for the job $Jid and ssh timeouts");
        }
    }

    oar_warn("[Leon] I exterminate the job $Jid\n");
    iolib::add_new_event($base,"EXTERMINATE_JOB",$Jid,"[Leon] I exterminate the job $Jid");
    
    iolib::set_job_state($base,$Jid,"Error");
    if ($refJob->{startTime} eq "0000-00-00 00:00:00"){
        iolib::set_running_date($base,$Jid);
    }

    iolib::set_finish_date($base,$Jid);
    iolib::set_job_message($base,$Jid,"job exterminated by Leon");
    iolib::remove_current_assigned_resources($base,$refJob->{assigned_moldable_job});
    iolib::job_arm_leon_timer($base,$Jid);
    $exitCode = 1;
}
iolib::unlock_table($base);

iolib::disconnect($base);

exit($exitCode);
