#!/usr/bin/perl
#Almighty module : check walltimes and jobs to frag
use strict;
use DBI();
use Data::Dumper;
use oar_iolib;
use oar_Judas qw(oar_debug oar_warn oar_error);
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use oar_Tools;

# Get job delete and checkpoint walltime values
my $leonSoftWalltime = oar_Tools::getDefaultLeonSoftWalltime();
my $leonWalltime = oar_Tools::getDefaultLeonWalltime();
init_conf("oar.conf");
if (is_conf("JOBDEL_SOFTWALLTIME")){
    $leonSoftWalltime = get_conf("JOBDEL_SOFTWALLTIME");
}
if (is_conf("JOBDEL_WALLTIME")){
    $leonWalltime = get_conf("JOBDEL_WALLTIME");
}

if ($leonWalltime <= $leonSoftWalltime){
    $leonWalltime = $leonSoftWalltime + 1;
    oar_warn("[sarko] (JOBDEL_WALLTIME <= JOBDEL_SOFTWALLTIME) so I must set JOBDEL_WALLTIME to $leonWalltime\n");
}

oar_debug("[sarko] JOBDEL_SOFTWALLTIME = $leonSoftWalltime; JOBDEL_WALLTIME = $leonWalltime\n");

# get script args
my $base = iolib::connect();
if (!defined($base)){
    oar_error("[sarko] Can not connect to the database\n");
    exit(1);
}

oar_debug("[sarko] Hello, identity control !!!\n");

my $guilty_found=0;
my $current = iolib::get_date($base);
$current = iolib::sql_to_local($current);
oar_debug("[sarko] Current time : $current\n");

# Look at leon timers
my @JobToFrag = iolib::get_timered_job($base);
my $Jid;
# Decide if OAR must retry to delete the job or just change values in the database
foreach my $Jid (@JobToFrag){
    my $refJob = iolib::get_job($base,$Jid);
    if (($refJob->{'state'} eq "Terminated") || ($refJob->{'state'} eq "Error")){
        iolib::job_fragged($base,$Jid);
        oar_debug("[sarko] I set to FRAGGED the job $Jid\n");
    }else{
        my $fragDate_sql = iolib::get_frag_date($base,$Jid);
        my $fragDate = iolib::sql_to_local($fragDate_sql);
        oar_debug("[sarko] frag date : $fragDate , $fragDate_sql\n");
        if (($current > $fragDate+$leonSoftWalltime) && ($current <= $fragDate+$leonWalltime)){
            oar_debug("[sarko] Leon will RE-FRAG bipbip of job $Jid\n");
            iolib::job_refrag($base,$Jid);
            $guilty_found=1;
        }elsif ($current > $fragDate+$leonWalltime){
            oar_debug("[sarko] Leon will EXTERMINATE bipbip of job $Jid\n");
            iolib::job_leon_exterminate($base,$Jid);
            $guilty_found=1;
        }else{
            oar_debug("[sarko] The leon timer is not yet expired for the job $Jid; I do nothing\n");
        }
    }
}


# Look at job walltimes
my @result = iolib::get_jobs_in_state($base, "Running");
foreach my $job (@result){
    my ($date, $start, $max);

    # Get starting time
    $date = $job->{start_time};
    #print "Job [$job{idJob}] startTime $date\n";
    $start = iolib::sql_to_local($date);

    # Get maxtime
    my $moldJob = iolib::get_current_moldable_job($base,$job->{assigned_moldable_job});
    $date = $moldJob->{moldableWalltime};
    $max = iolib::sql_to_duration($date);

    oar_debug("[sarko] Job [$job->{job_id}] from $start with $max; current time=$current");
    if ($current > $start+$max){
        oar_debug(" (Elapsed)");
        $guilty_found=1;
        iolib::lock_table($base,["frag_jobs","event_logs"]);
        iolib::frag_job($base, $job->{job_id});
        iolib::unlock_table($base);
        iolib::add_new_event($base,"WALLTIME",$job->{job_id},"[sarko] Job [$job->{job_id}] from $start with $max; current time=$current (Elapsed)");
    }elsif (($job->{checkpoint} > 0) && ($job->{auto_checkpointed} eq "NO") && ($current >= ($start+$max-$job->{checkpoint}))){
        # OAR must notify the job to checkpoint itself
        oar_debug("[sarko] Send checkpoint signal to the job $job->{job_id}\n");
        # Retrieve node names used by the job
        my @hosts = iolib::get_job_current_hostnames($base,$job->{job_id});
        iolib::add_new_event($base,"CHECKPOINT",$job->{job_id},"User oar (sarko) requested a checkpoint on the job $job->{job_id}");
        my $timeoutSSH = oar_Tools::getSSHTimeout();
        my $strComment;
        my @exitCodes;
        # Timeout the ssh command
        eval {
            $SIG{ALRM} = sub { die "alarm\n" };
            alarm($timeoutSSH);
            @exitCodes = oar_Tools::signalOarexec($hosts[0],$job->{job_id},"SIGUSR2",1);
            alarm(0);
        };
        if ($@){
            if ($@ eq "alarm\n"){
                $strComment = "[sarko] Cannot contact $hosts[0], operation timouted ($timeoutSSH s). So I cannot send checkpoint signal to the job $job->{job_id}";
                oar_warn("$strComment\n");
                iolib::add_new_event($base,"CHECKPOINT_ERROR",$job->{job_id},$strComment);
            }else{
                $strComment = "[sarko] An unknown error occured during the sending of the checkpoint signal to the job $job->{job_id} on the host $hosts[0]";
                oar_warn("$strComment\n");
                iolib::add_new_event($base,"CHECKPOINT_ERROR",$job->{job_id},$strComment);
            }
        }else{
            if ($exitCodes[0] == 0){
                iolib::set_job_autoCheckpointed($base, $job->{job_id});
                $strComment = "[sarko] The job $job->{job_id} was notified to checkpoint itself (send SIGUSR2) on the node $hosts[0]";
                oar_debug("$strComment\n");
                iolib::add_new_event($base,"CHECKPOINT_SUCCESSFULL",$job->{job_id},$strComment);
            }else{
                $strComment = "[sarko] The kill command return a bad exit code (@exitCodes) for the job $job->{job_id} on the node $hosts[0]";
                oar_warn("$strComment\n");
                iolib::add_new_event($base,"CHECKPOINT_ERROR",$job->{job_id},$strComment);
            }
        }
    }
    oar_debug("\n");
}



## Retrieve nodes with expiryDates in the past
## special for Desktop computing
#my @nodes = iolib::get_expired_nodes($base);
#if (defined @nodes) {
#    # First mark the nodes as dead
#    foreach my $node (@nodes) {
#        iolib::set_node_nextState($base, $node, 'Suspected');
#    }
#    # Then notify Almighty
#    my $remote_host = get_conf("SERVER_HOSTNAME");
#    my $remote_port = get_conf("SERVER_PORT");
#
#    oar_Tools::notifyAlmighty($remote_host,$remote_port,"ChState");
#}

iolib::disconnect($base);

exit $guilty_found;
