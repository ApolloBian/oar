#!/usr/bin/perl
# Request some extratime for a job
# This feature is not compatible with runtime suspend/resume of jobs

use strict;
use warnings;
use DBI();
use OAR::IO;
use OAR::Conf qw(init_conf dump_conf get_conf is_conf get_conf_with_default_param);
use Getopt::Long;
use OAR::Version;

my $Old_umask = sprintf("%lo",umask());
umask(oct("022"));

# Display command help
sub usage {
    return <<EOS;
Usage: $0 <job_id>

Options:
  -V, --version   print OAR version
  -h, --help      print help

EOS
}

sub version {
    print("OAR version : ".OAR::Version::get_version()."\n");
    exit(0);
}

sub list($);

# Retrieve informations from OAR configuration file
init_conf($ENV{OARCONFFILE});
my $REMOTE_HOST = get_conf("SERVER_HOSTNAME");
my $REMOTE_PORT = get_conf("SERVER_PORT");
my $EXTRATIME_DELAY = get_conf_with_default_param("EXTRATIME_DELAY", 0);
my $EXTRATIME_DURATION = get_conf_with_default_param("EXTRATIME_DURATION", 0);

# Parse command line
Getopt::Long::Configure("gnu_getopt");

GetOptions (
            "help|h" => sub { print(usage()); exit(0); },
            "version|V" => sub { print("OAR version: ".OAR::Version::get_version()."\n"); exit(0); },
           ) or exit(1);

if ($#ARGV < 0) {
    warn(usage());
    exit(1);
}

my $jobid = shift;
my $lusr= $ENV{OARDO_USER};

my $dbh = OAR::IO::connect_ro();
my $job = OAR::IO::get_job($dbh, $jobid);

if (not defined($job)) {
    warn("Could not find job $jobid.\n");
    exit 1;
}

my $moldable = OAR::IO::get_current_moldable_job($dbh, $job->{assigned_moldable_job});

if ($job->{job_user} ne $lusr) { 
    warn("Job $jobid does not belong to you.\n");
    exit 1;
}
if ($job->{state} ne "Running") { 
    warn("Job $jobid in not running, you can only request extra time for a running job.\n");
    exit 1;
}

my $allowed_request_date;
if ($EXTRATIME_DELAY < 0) {
    $allowed_request_date = $job->{start_time} + $moldable->{moldable_walltime} + $EXTRATIME_DELAY;
} else {
    $allowed_request_date = $job->{start_time} + $EXTRATIME_DELAY;
}

my $now = OAR::IO::get_date($dbh);
my $extratime_current = OAR::IO::get_extra_time_for_job($dbh, $jobid);
OAR::IO::disconnect($dbh);

if (defined($extratime_current)) {
    if ($extratime_current >= $EXTRATIME_DURATION) {
        print("Extra time already added for job $jobid.\nYou already got ".$extratime_current."s and cannot get more.\n");
    } elsif ($extratime_current == 0) {
        print("Extra time request already registerd for job $jobid.\nNo extra time could be added so far.\n");
    } else {
        print("Extra time request already registerd for job $jobid.\n".$extratime_current."s were already added so far (max possible is $EXTRATIME_DURATION).\n");
    }
    exit 1;
} elsif ($allowed_request_date > $now) { 
    if ($EXTRATIME_DELAY < 0) {
        print("You cannot request extra time for job $jobid for now. It will only be possible in the last ".-$EXTRATIME_DELAY."s before the end of the job (from ".localtime($allowed_request_date)." onwards).\n");
    } else { 
        print("You cannot request extra time for job $jobid for now. It will only be possible in the last ".$EXTRATIME_DELAY."s after the start of the job (from ".localtime($allowed_request_date)." onwards).\n");
    }
    exit 1;
}
$dbh = OAR::IO::connect();
OAR::IO::add_extra_time_request($dbh, $jobid);
print ("Your extra time request for job $jobid is registered, it will be handled shortly.\n");

OAR::IO::disconnect($dbh);

OAR::Tools::notify_tcp_socket($REMOTE_HOST,$REMOTE_PORT,"Extratime");

exit(0);
