#!/usr/bin/perl
# Request some extratime for a job
# This feature is not compatible with runtime suspend/resume of jobs

use strict;
use warnings;
use DBI();
use OAR::IO;
use OAR::Conf;
use Getopt::Long;
use OAR::Version;

my $Old_umask = sprintf("%lo",umask());
umask(oct("022"));

# Display command help
sub usage {
    return <<EOS;
Usage:
  $0 [<options>] <job_id> [<extra_time>]

Manage extra time requests for a job.
- If extra time is given, the command requests the addition of some extra time
  to the job or update a previous request.
- If no extra time is given, the command shows the current extra time status for
  the job.
Job must be running.
Extra time is to be given as an number of seconds.

Options:
  -D, --delay-next-jobs  allow extra time to delay the next batch jobs
  -V, --version          print OAR version
  -h, --help             print help

EOS
}

sub version {
    print("OAR version: ".OAR::Version::get_version()."\n");
    exit(0);
}

# Retrieve informations from OAR configuration file
OAR::Conf::init_conf($ENV{OARCONFFILE});
my $REMOTE_HOST = get_conf("SERVER_HOSTNAME");
my $REMOTE_PORT = get_conf("SERVER_PORT");

# Parse command line
Getopt::Long::Configure("gnu_getopt");

my $force = undef;
GetOptions (
            "delay-next-jobs|D" => \$force,
            "help|h" => sub { print(usage()); exit(0); },
            "version|V" => sub { print("OAR version: ".OAR::Version::get_version()."\n"); exit(0); },
           ) or exit(1);

my $jobid = shift;
if (not defined($jobid)) {
    warn(usage());
    exit(1);
}

my $dbh = OAR::IO::connect();

my $job = OAR::IO::get_job($dbh, $jobid);
if (not defined($job)) {
    warn("Could not find job $jobid.\n");
    exit 1;
}

my $EXTRA_TIME_DURATION = OAR::Conf::get_conf_from_hash_with_default_value("EXTRA_TIME_DURATION", $job->{queue_name}, 0);
my $EXTRA_TIME_REQUEST_DELAY = OAR::Conf::get_conf_from_hash_with_default_value("EXTRA_TIME_REQUEST_DELAY", $job->{queue_name}, 0);
my $EXTRA_TIME_MINIMUM_WALLTIME = OAR::Conf::get_conf_from_hash_with_default_value("EXTRA_TIME_MINIMUM_WALLTIME", $job->{queue_name}, 0);
my $EXTRA_TIME_FORCE_ALLOWED_USERS = OAR::Conf::get_conf_from_hash_with_default_value("EXTRA_TIME_DELAY_NEXT_JOBS_ALLOWED_USERS", $job->{queue_name}, "");

my $lusr=$ENV{OARDO_USER};
if ($EXTRA_TIME_DURATION <= 0 and not grep(/^$lusr$/,('root','oar'))) { 
    warn("You are not allowed to add extra time.\n");
    exit 1;
} elsif ($EXTRA_TIME_DURATION < 0) {
    warn("The extra time functionality is disabled.\n");
    exit 1;
}

if ($job->{job_user} ne $lusr and not grep(/^$lusr$/,('root','oar'))) { 
    warn("Job $jobid does not belong to you.\n");
    exit 1;
}

if ($job->{state} ne "Running") { 
    warn("Job $jobid is in state '".$job->{state}."': you can only use this command with a running job.\n");
    exit 1;
}

sub print_extratime($) {
    my $current_extratime = shift;
    if (not defined($current_extratime)) {
        $current_extratime = { granted => 0, pending => 0, force => 'NO' };
    }
    print("Pending requested time: ".$current_extratime->{pending}." s".(($current_extratime->{force} eq 'YES' and $current_extratime->{pending} > 0)?" (can delay other jobs)":"")."\n");
    print("Already granted time: ".$current_extratime->{granted}." s\n");
    print("Maximum allowed time: ".$EXTRA_TIME_DURATION." s\n");
}

my $requested_extratime = shift;
if (not defined($requested_extratime)) {
    my $current_extratime = OAR::IO::get_extratime_for_job($dbh, $jobid); # no lock here
    print_extratime($current_extratime);
    exit 0;
} elsif (not $requested_extratime =~ /^\d+$/) {
    warn("Bad extra time request.\n");
    exit 1;
}
if (defined($force) and $EXTRA_TIME_FORCE_ALLOWED_USERS ne "*" and not grep(/^$lusr$/,('root','oar',split(/[,\s]+/,$EXTRA_TIME_FORCE_ALLOWED_USERS)))) {
    warn("You are not allowed to use the --delay-next-jobs or -D option.\n");
    exit 1;
}

my $moldable = OAR::IO::get_current_moldable_job($dbh, $job->{assigned_moldable_job});
if ($moldable->{moldable_walltime} < $EXTRA_TIME_MINIMUM_WALLTIME) {
    warn("You cannot request extra time for a job with a walltime smaller than $EXTRA_TIME_MINIMUM_WALLTIME s.\n");
    exit 1;

}

my $now = OAR::IO::get_date($dbh);
my $suspended = OAR::IO::get_job_suspended_sum_duration($dbh, $jobid, $now);
my $allowed_request_date = $job->{start_time} + $moldable->{moldable_walltime} + $suspended - $EXTRA_TIME_REQUEST_DELAY;
if ($EXTRA_TIME_REQUEST_DELAY > 0 and $allowed_request_date > $now) {
    warn("You cannot request extra time for job $jobid for now. It will only be possible in the last ".$EXTRA_TIME_REQUEST_DELAY." s before the end of the job (from ".localtime($allowed_request_date)." onwards).\n");
    exit 1;
}

OAR::IO::lock_table($dbh,['oarextratime']);

my $current_extratime = OAR::IO::get_extratime_for_job($dbh, $jobid); # locked here
if (defined($current_extratime)) {
    if ($current_extratime->{granted} + $requested_extratime > $EXTRA_TIME_DURATION and not grep(/^$lusr$/,('root','oar'))) { 
        warn("Request cannot be accepted: you cannot get more than ".$EXTRA_TIME_DURATION." s of extra time.\n");
        exit 1
    }
    OAR::IO::update_extratime_request($dbh,$jobid,(defined($force)?'YES':'NO'),$requested_extratime, undef);
    print ("Extra time request updated for job $jobid. It will be handled shortly.\n");
} else {
    if ($requested_extratime > $EXTRA_TIME_DURATION and not grep(/^$lusr$/,('root','oar'))) {
        warn("Request cannot be accepted: you cannot get more than ".$EXTRA_TIME_DURATION." s of extra time.\n");
        exit 1
    }
    OAR::IO::add_extratime_request($dbh,$jobid,(defined($force)?'YES':'NO'),$requested_extratime);
    print ("Extra time request registered for job $jobid. It will be handled shortly.\n");
}

OAR::IO::unlock_table($dbh);

OAR::IO::disconnect($dbh);

OAR::Tools::notify_tcp_socket($REMOTE_HOST,$REMOTE_PORT,"Extratime");
exit(0);
