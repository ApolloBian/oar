#!/usr/bin/perl
# Request some extratime for a job
# This feature is not compatible with runtime suspend/resume of jobs

use strict;
use warnings;
use DBI();
use OAR::IO;
use OAR::Version;
use OAR::Extratime;
use Getopt::Long;
use Data::Dumper;

my $Old_umask = sprintf("%lo",umask());
umask(oct("022"));

# Display command help
sub usage {
    return <<EOS;
Usage:
  $0 [options] <job_id> [duration]

Manage extra time requests for a job.
- If no duration is given, the command shows the current extra time status for
  the job.
- If a duration is given, the command requests the addition of that duration to
  the walltime of the job, or update a pending request.
The extra time duration is to be given as a number of seconds.
The job must be running to request extra time.

Options:
  -D, --delay-next-jobs  allow an extra time request to succeed even if it
                         must delay other jobs, including other users' jobs
  -V, --version          print OAR version
  -h, --help             print help

EOS
}

sub version {
    print("OAR version: ".OAR::Version::get_version()."\n");
    exit(0);
}

# Parse command line
Getopt::Long::Configure("gnu_getopt");
my $delay_next_jobs = undef;
GetOptions (
            "delay-next-jobs|D" => \$delay_next_jobs,
            "help|h" => sub { print(usage()); exit(0); },
            "version|V" => sub { print("OAR version: ".OAR::Version::get_version()."\n"); exit(0); },
           ) or exit(1);

my $jobid = shift;
my $requested_duration = shift;
if (not defined($jobid) or (not defined($requested_duration) and defined($delay_next_jobs)) or (defined($requested_duration) and $requested_duration !~ /^\d+$/)) {
    print(usage());
    exit(4);
}

my $dbh = OAR::IO::connect();
# Command is a query only, no request
if (not defined($requested_duration)) {
    my ($extratime, $job_state, $job_walltime) = OAR::Extratime::get($dbh, $jobid);
    if ($job_state eq "Running") {
        print("Extra time status for job $jobid (job is running):\n");
        printf(" Current job walltime:        %8ds\n",$job_walltime);
        printf(" Maximum possible extra time: %8ds\n",$extratime->{possible});
        printf(" Already granted extra time:  %8ds%s\n",$extratime->{granted},(exists($extratime->{granted_with_delaying_next_jobs})?" (of which ".$extratime->{granted_with_delaying_next_jobs}."s may have delayed other jobs)":""));
        if ($extratime->{pending} > 0) {
            printf(" Pending request/unsatisfied: %8ds%s\n",$extratime->{pending},(defined($extratime->{delay_next_jobs}) and $extratime->{delay_next_jobs} eq "YES")?"(will possibly delay next jobs)":"");
        }
    } elsif($job_state eq "Unknown") {
        print("Unknown job.\n");
        exit 2;
    } else {
        print("Extra time status for job $jobid (job is not running):\n");
        printf(" Granted extra time: %8ds%s\n",$extratime->{granted},(exists($extratime->{granted_with_delaying_next_jobs})?" (of which ".$extratime->{granted_with_delaying_next_jobs}."s may have delayed other jobs)":""));
    } 
    OAR::IO::disconnect($dbh);
    exit 0;
} 

# Request
my $lusr=$ENV{OARDO_USER};
my ($error, undef, $status, $message) = OAR::Extratime::request($dbh, $jobid, $lusr, $requested_duration, defined($delay_next_jobs)?"YES":"NO");
OAR::IO::disconnect($dbh);
print(ucfirst("$status: $message.\n"));
exit($error);
