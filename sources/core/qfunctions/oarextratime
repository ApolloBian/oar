#!/usr/bin/perl
# Request some extratime for a job
# This feature is not compatible with runtime suspend/resume of jobs

use strict;
use warnings;
use Data::Dumper;
use DBI();
use OAR::IO qw(lock_table unlock_table);
use OAR::Conf qw(init_conf dump_conf get_conf is_conf get_conf_with_default_param);
use OAR::Tools;
use Getopt::Long;
use OAR::Version;

### IO.pm ######################################

sub add_extra_time_request($$) {
    my $dbh = shift;
    my $job_id = shift;
    OAR::IO::lock_table($dbh, ["extratime"]);
    $dbh->do("INSERT INTO extratime (job_id) VALUES ($job_id)");
    OAR::IO::unlock_table($dbh);
}

sub get_extra_time_for_job($$) {
    my $dbh = shift;
    my $job_id = shift;
    my $sth = $dbh->prepare("SELECT time FROM extratime WHERE job_id = $job_id");
    $sth->execute();
    my $ref = $sth->fetchrow_hashref();
    my $time;
    if (defined($ref)) {
        $time = $ref->{time};
    }
    return $time;
}

################################################


my $Old_umask = sprintf("%lo",umask());
umask(oct("022"));

# Display command help
sub usage {
    return <<EOS;
Usage: $0 <job_id>

Options:
  -V, --version   print OAR version
  -h, --help      print help

EOS
}

sub version {
    print("OAR version : ".OAR::Version::get_version()."\n");
    exit(0);
}

sub list($);

# Retrieve informations from OAR configuration file
init_conf($ENV{OARCONFFILE});
my $REMOTE_HOST = get_conf("SERVER_HOSTNAME");
my $REMOTE_PORT = get_conf("SERVER_PORT");
my $EXTRATIME_DELAY = get_conf_with_default_param("EXTRATIME_DELAY", 3600);
my $EXTRATIME_DURATION = get_conf_with_default_param("EXTRATIME_DURATION", 3600);

# Parse command line
Getopt::Long::Configure("gnu_getopt");

GetOptions (
            "help|h" => sub { print(usage()); exit(0); },
            "version|V" => sub { print("OAR version: ".OAR::Version::get_version()."\n"); exit(0); },
           ) or exit(1);

if ($#ARGV < 0) {
    warn(usage());
    exit(1);
}

my $jobid = shift;
my $lusr= $ENV{OARDO_USER};

my $dbh = OAR::IO::connect_ro();
my $job = OAR::IO::get_job($dbh, $jobid);

if (not defined($job)) {
    warn("Could not find job $jobid.\n");
    exit 1;
}

my $moldable = OAR::IO::get_current_moldable_job($dbh, $job->{assigned_moldable_job});

if ($job->{job_user} ne $lusr) { 
    warn("Job $jobid does not belong to you.\n");
    exit 1;
}
if ($job->{state} ne "Running") { 
    warn("Job $jobid in not running, you can only request extra time for a running job.\n");
    exit 1;
}

my $request_date = $job->{start_time} + $moldable->{moldable_walltime} - $EXTRATIME_DELAY;
my $now = OAR::IO::get_date($dbh);
my $extratime_current = get_extra_time_for_job($dbh, $jobid);
OAR::IO::disconnect($dbh);

if (defined($extratime_current)) {
    if ($extratime_current >= $EXTRATIME_DURATION) {
        print("Extra time already added for job $jobid.\nYou already got ".$extratime_current."s and cannot get more.\n");
    } elsif ($extratime_current == 0) {
        print("Extra time request already registerd for job $jobid.\nNo extra time could be added so far.\n");
    } else {
        print("Extra time request already registerd for job $jobid.\n".$extratime_current."s were already added so far (max possible is $EXTRATIME_DURATION).\n");
    }
    exit 1;
} elsif ($request_date > $now) { 
    print("You cannot request extra time for job $jobid for now. It will only be possible in the last ".$EXTRATIME_DELAY."s before the end of the job (from ".localtime($request_date)." onwards).\n");
    exit 1;
}
$dbh = OAR::IO::connect();
add_extra_time_request($dbh, $jobid);
print ("Your extra time request for job $jobid is registered, it will be handled shortly.\n");

OAR::IO::disconnect($dbh);

OAR::Tools::notify_tcp_socket($REMOTE_HOST,$REMOTE_PORT,"Extratime");

exit(0);
