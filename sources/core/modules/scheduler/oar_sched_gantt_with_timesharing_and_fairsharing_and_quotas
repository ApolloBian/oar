#!/usr/bin/perl
# $Id$
#-d:DProf
#-d:NYTProf     --> nytprofhtml

use strict;
use DBI();
use OAR::IO;
use Data::Dumper;
use OAR::Modules::Judas qw(oar_debug oar_warn oar_error set_current_log_category);
use OAR::Conf qw(init_conf dump_conf get_conf is_conf get_conf_with_default_param);
use OAR::Schedulers::Gantt;
use OAR::Schedulers::Quotas;
use Storable qw(dclone);
use Time::HiRes qw(gettimeofday);

select(STDOUT); $| = 1;

# Log category
set_current_log_category('scheduler');
my $scheduler_name = "oar_sched_gantt_with_timesharing_and_fairsharing_and_quotas";
my $Quota_file = "/etc/oar/scheduler_quotas.conf";

init_conf($ENV{OARCONFFILE});

###############################################################################
# Fairsharing parameters #
##########################
# Avoid problems if there are too many waiting jobs
my $Karma_max_number_of_jobs_treated_per_user = 30;
if (is_conf("SCHEDULER_FAIRSHARING_MAX_JOB_PER_USER")) {
    $Karma_max_number_of_jobs_treated_per_user = get_conf("SCHEDULER_FAIRSHARING_MAX_JOB_PER_USER");
}
# number of seconds to consider for the fairsharing
my $Karma_window_size = 3600 * 30 * 24;
if (is_conf("SCHEDULER_FAIRSHARING_WINDOW_SIZE")) {
    $Karma_window_size = get_conf("SCHEDULER_FAIRSHARING_WINDOW_SIZE");
}
# specify the target percentages for project names (0 if not specified)
my $Karma_project_targets = { first => 75, default => 25 };
if (is_conf("SCHEDULER_FAIRSHARING_PROJECT_TARGETS")) {
    $Karma_project_targets = eval(get_conf("SCHEDULER_FAIRSHARING_PROJECT_TARGETS").";");
    if ($@) {
        oar_error("[$scheduler_name] Syntax error in configuration file: SCHEDULER_FAIRSHARING_PROJECT_TARGETS\n");
        exit (1);
    }
}

# specify the target percentages for users (0 if not specified)
my $Karma_user_targets = { oar => 100 };
if (is_conf("SCHEDULER_FAIRSHARING_USER_TARGETS")) {
    $Karma_user_targets = eval(get_conf("SCHEDULER_FAIRSHARING_USER_TARGETS").";");
    if ($@) {
        oar_error("[$scheduler_name] Syntax error in configuration file: SCHEDULER_FAIRSHARING_USER_TARGETS\n");
        exit (1);
    }
}
#print Dumper($Karma_user_targets);
# weight given to each criteria
my $Karma_coeff_project_consumption = 0;
if (is_conf("SCHEDULER_FAIRSHARING_COEF_PROJECT")) {
    $Karma_coeff_project_consumption = get_conf("SCHEDULER_FAIRSHARING_COEF_PROJECT");
} 
my $Karma_coeff_user_consumption = 2;
if (is_conf("SCHEDULER_FAIRSHARING_COEF_USER")) {
    $Karma_coeff_user_consumption = get_conf("SCHEDULER_FAIRSHARING_COEF_USER");
}
my $Karma_coeff_user_asked_consumption = 1;
if (is_conf("SCHEDULER_FAIRSHARING_COEF_USER_ASK")) {
    $Karma_coeff_user_asked_consumption = get_conf("SCHEDULER_FAIRSHARING_COEF_USER_ASK");
}

###############################################################################
# Tokens #
##########
my $Token_scripts = {};
if (is_conf("SCHEDULER_TOKEN_SCRIPTS")) {
    $Token_scripts = eval(get_conf("SCHEDULER_TOKEN_SCRIPTS").";");
    if ($@) {
        oar_error("[$scheduler_name] Syntax error in configuration file: SCHEDULER_TOKEN_SCRIPTS\n");
        exit (1);
    }
}
###############################################################################
# Quotas #
##########
my ($Gantt_quotas, $err) = OAR::Schedulers::Quotas::read_conf_file("$Quota_file");
if (defined($err)){
    oar_error("[$scheduler_name] $err; QUOTA DISABLED\n");
}
###############################################################################
my $initial_time = time();
my $timeout = 10;
my $Minimum_timeout_per_job = 0;
if (is_conf("SCHEDULER_TIMEOUT")){
    $timeout = get_conf("SCHEDULER_TIMEOUT");
}

# Constant duration time of a besteffort job
my $besteffort_duration = 5*60;

# $security_time_overhead is the security time (second) used to be sure there
# are no problem with overlaping jobs
my $security_time_overhead = 60;
if (is_conf("SCHEDULER_JOB_SECURITY_TIME")){
    $security_time_overhead = get_conf("SCHEDULER_JOB_SECURITY_TIME");
}

my $minimum_hole_time = 0;
if (is_conf("SCHEDULER_GANTT_HOLE_MINIMUM_TIME")){
    $minimum_hole_time = get_conf("SCHEDULER_GANTT_HOLE_MINIMUM_TIME");
}

my $Order_part = get_conf("SCHEDULER_RESOURCE_ORDER");

my @Sched_available_suspended_resource_type;
my $sched_available_suspended_resource_type_tmp = get_conf("SCHEDULER_AVAILABLE_SUSPENDED_RESOURCE_TYPE");
if (!defined($sched_available_suspended_resource_type_tmp)){
    push(@Sched_available_suspended_resource_type, "default");
}else{
    @Sched_available_suspended_resource_type = split(" ",$sched_available_suspended_resource_type_tmp);
}

# Look at resources that we must add for each job
my $Resources_to_always_add_type = get_conf("SCHEDULER_RESOURCES_ALWAYS_ASSIGNED_TYPE");
my @Resources_to_always_add = ();

my $Constraints_iterations = get_conf_with_default_param("SCHEDULER_CONSTRAINTS_ITERATIONS",4);

my $current_time ;

my $queue;
if (defined($ARGV[0]) && defined($ARGV[1]) && $ARGV[1] =~ m/\d+/m) {
    $queue = $ARGV[0];
    $current_time = $ARGV[1];
}else{
    oar_error("[$scheduler_name] No queue specified on command line\n");
    exit(1);
}

# Init
my $base = OAR::IO::connect();
my $base_ro = OAR::IO::connect_ro();

oar_debug("[$scheduler_name] Starting scheduler for queue $queue at time $current_time\n");

# First check states of resources that we must add for every job
if (defined($Resources_to_always_add_type)){
    my $tmp_result_state_resources = OAR::IO::get_specific_resource_states($base,$Resources_to_always_add_type);
    if ($#{$tmp_result_state_resources->{"Suspected"}} >= 0){
        oar_warn("[$scheduler_name] Some of the resources matching the SCHEDULER_RESOURCES_ALWAYS_ASSIGNED_TYPE configuration directive are Suspected. No job can be scheduled. Exiting\n");
        exit(1);
    }else{
        if (defined($tmp_result_state_resources->{"Alive"})){
            @Resources_to_always_add = @{$tmp_result_state_resources->{"Alive"}};
            oar_debug("[$scheduler_name] The following Alive resources matching the SCHEDULER_RESOURCES_ALWAYS_ASSIGNED_TYPE configuration directive will be added to every job: @Resources_to_always_add\n");
        }
    }
}

# Create the Gantt Diagrams
#Init the gantt chart with all resources
my ($Max_resources, $All_resource_list_vec, $Only_default_type_resource_vec) = OAR::IO::get_vecs_resources($base);

my $Gantt = {};
$Gantt->{default}->{""}->{""}->{""} = OAR::Schedulers::Gantt::new($Max_resources, $minimum_hole_time);
OAR::Schedulers::Gantt::add_new_resources($Gantt->{default}->{""}->{""}->{""}, $All_resource_list_vec);
my $quota_accounting_data = OAR::Schedulers::Quotas::new($security_time_overhead);
my $contraints = {};

# Token feature (see oar.conf)
# Keep the track of the usage for each token
my %Token_values;

oar_debug("[$scheduler_name] Begin phase 1 (current jobs)\n");
# Take care of currently scheduled jobs (gantt in the database)
my ($order,%already_scheduled_jobs) = OAR::IO::get_gantt_scheduled_jobs($base);
foreach my $i (@{$order}){
    my $gantt_name = "default";
    my $placeholder_name = "";
    my $allowed_name = "";
    my $timesharing_user = "";
    my $timesharing_name = "";
    my $types = OAR::IO::get_job_types_hash($base,$i);
    my @type_list = sort(keys(%{$types}));
    # Do not take care of besteffort jobs
    if ((! defined($types->{besteffort})) or ($queue eq "besteffort")){
        my @resource_list = @{$already_scheduled_jobs{$i}->[3]};
        my $resource_list_vec = $already_scheduled_jobs{$i}->[10];
        my $job_duration = $already_scheduled_jobs{$i}->[1];
        if ($already_scheduled_jobs{$i}->[4] eq "Suspended"){
            # Remove resources of the type specified in SCHEDULER_AVAILABLE_SUSPENDED_RESOURCE_TYPE
            ($resource_list_vec, @resource_list) = OAR::IO::get_job_current_resources($base, $already_scheduled_jobs{$i}->[7],\@Sched_available_suspended_resource_type);
            next if ($#resource_list < 0);
        }
        if ($already_scheduled_jobs{$i}->[8] eq "YES"){
            # This job was suspended so we must recalculate the walltime
            $job_duration += OAR::IO::get_job_suspended_sum_duration($base,$i,$current_time);
        }

        if (defined($types->{container})){ # A container job cannot be placeholder or allowed or timesharing. 
            my $container_name;
            if ($types->{container} ne "true") {
                $container_name = "container:$types->{container}";
            } else {
                $container_name = "container:$i";
            }
            if (defined($Gantt->{$container_name})) {
                oar_debug("[$scheduler_name] [$i] container job, adding a hole in gantt: ($container_name,,,)\n");
                $Gantt->{$container_name}->{""}->{""}->{""} = OAR::Schedulers::Gantt::add_1_hole($Gantt->{$container_name}->{""}->{""}->{""}, $already_scheduled_jobs{$i}->[0], $job_duration + $security_time_overhead, $resource_list_vec);
            } else {
                oar_debug("[$scheduler_name] [$i] container job, creating gantt: ($container_name,,,)\n");
                $Gantt->{$container_name}->{""}->{""}->{""} = 
                    OAR::Schedulers::Gantt::new_with_1_hole($Max_resources, $minimum_hole_time, $already_scheduled_jobs{$i}->[0], $job_duration + $security_time_overhead, $resource_list_vec, $All_resource_list_vec);
            }
        } else {
            ($gantt_name, $placeholder_name, $allowed_name, $timesharing_name, $timesharing_user) = 
                OAR::Schedulers::Gantt::manage_gantt_hierarchy($Gantt, $already_scheduled_jobs{$i}->[6], $already_scheduled_jobs{$i}->[5], $types, undef, "[$scheduler_name] [$i]");
            OAR::Schedulers::Quotas::update_accounting_counters(
                                                $quota_accounting_data,
                                                unpack("%32b*", $resource_list_vec & $Only_default_type_resource_vec),
                                                $already_scheduled_jobs{$i}->[0],
                                                $job_duration + $security_time_overhead,
                                                $already_scheduled_jobs{$i}->[2],
                                                $already_scheduled_jobs{$i}->[9],
                                                \@type_list,
                                                $already_scheduled_jobs{$i}->[5]
                                                                     );
        }

        #Fill all other gantts
        OAR::Schedulers::Gantt::fill_gantt_hierarchy($Gantt, $already_scheduled_jobs{$i}->[0], $job_duration + $security_time_overhead, $resource_list_vec, $gantt_name ,$placeholder_name, $timesharing_name, $timesharing_user, "[$scheduler_name] [$i]"); 

    }
}

oar_debug("[$scheduler_name] End phase 1 (current jobs)\n");

# End of the initialisation
# Begining of the real scheduling

# Get list of Alive resources
my ($alive_resources_vector, @alive_resources)= OAR::IO::get_resource_ids_in_state($base,"Alive");

# ENERGY SAVING: add fake occupations/holes from energy saving configuration 
# CM part and Hulot part (wake up nodes in energy saving mode)
if (is_conf("SCHEDULER_NODE_MANAGER_WAKE_UP_CMD") or (get_conf("ENERGY_SAVING_INTERNAL") eq "yes" and is_conf("ENERGY_SAVING_NODE_MANAGER_WAKE_UP_CMD"))){
    oar_debug("[$scheduler_name] Begin EnergySaving phase\n");
    # Check the resources that can be waked_up or shut down
    my $upto_availability = OAR::IO::get_energy_saving_resources_availability($base, $current_time);
    foreach my $t (keys(%{$upto_availability})){
        my $vec = '';
        foreach my $r (@{$upto_availability->{$t}}){
            vec($alive_resources_vector, $r, 1) = 1;
            vec($vec,$r,1) = 1;
        }
        #Fill all the gantts
        foreach my $c (keys(%{$Gantt})){
            foreach my $p (keys(%{$Gantt->{$c}})){
                foreach my $u (keys(%{$Gantt->{$c}->{$p}})){
                    foreach my $n (keys(%{$Gantt->{$c}->{$p}->{$u}})){
                        oar_debug("[$scheduler_name] Add energy saving occupation in gantt ($c,$p,$u,$n)\n");
                        OAR::Schedulers::Gantt::set_occupation( $Gantt->{$c}->{$p}->{$u}->{$n},
                                                 $t,
                                                 OAR::Schedulers::Gantt::get_infinity_value(),
                                                 $vec
                                              );
                    }
                }
            }
        }
    }
    oar_debug("[$scheduler_name] End EnergySaving phase\n");
}
# CM part
 
my ($Dead_resources_vec, @Dead_resources) = OAR::IO::get_resource_ids_in_state($base,"Dead");

oar_debug("[$scheduler_name] Begin phase 2 (waiting jobs)\n");
my $constraints = {};
my @jobs = OAR::IO::get_fairsharing_jobs_to_schedule($base,$queue,$Karma_max_number_of_jobs_treated_per_user);
###############################################################################
# Sort jobs depending on their previous usage
# Karma sort algorithm
my $Karma_sum_time = OAR::IO::get_sum_accounting_window($base,$queue,$current_time - $Karma_window_size,$current_time);
$Karma_sum_time->{ASKED} = 1 if (!defined($Karma_sum_time->{ASKED}));
$Karma_sum_time->{USED} = 1 if (!defined($Karma_sum_time->{USED}));

my $Karma_projects = OAR::IO::get_sum_accounting_for_param($base,$queue,"accounting_project",$current_time - $Karma_window_size,$current_time);
my $Karma_users = OAR::IO::get_sum_accounting_for_param($base,$queue,"accounting_user",$current_time - $Karma_window_size,$current_time);

sub karma($){
    my $j = shift;

    my $note = 0;
    $note = $Karma_coeff_project_consumption * (($Karma_projects->{$j->{project}}->{USED} / $Karma_sum_time->{USED}) - ($Karma_project_targets->{$j->{project}} / 100));
    $note += $Karma_coeff_user_consumption * (($Karma_users->{$j->{job_user}}->{USED} / $Karma_sum_time->{USED}) - ($Karma_user_targets->{$j->{job_user}} / 100));
    $note += $Karma_coeff_user_asked_consumption * (($Karma_users->{$j->{job_user}}->{ASKED} / $Karma_sum_time->{ASKED}) - ($Karma_user_targets->{$j->{job_user}} / 100));

    return($note);
}

###############################################################################

@jobs = sort({karma($a) <=> karma($b)} @jobs);
my $job_index = 0;
while (($job_index <= $#jobs) and ((time() - $initial_time) < $timeout)){
    my $j = $jobs[$job_index];
    my $i = $j->{job_id};
    $job_index ++;
    oar_debug("[$scheduler_name] [$j->{job_id}] Start scheduling (Karma note = ".karma($j).")\n");
    
    my $gantt_to_use = $Container_gantt_hash{0};
    my $container_num = 0;
    my $types = OAR::IO::get_job_types_hash($base,$j->{job_id});
    my @type_list = sort(keys(%{$types}));

    my $scheduler_init_date = $current_time;

    if (defined($types->{postpone})) {
        my $postpone_time_sec = OAR::IO::sql_to_local($types->{postpone});
        if ($scheduler_init_date < $postpone_time_sec) {
            $scheduler_init_date = $postpone_time_sec;
            oar_debug("[$scheduler_name] [$j->{job_id}] job is postponed to $types->{postpone}\n");
        }
    }

    if (defined($types->{expire})) {
        my $expire_time_sec = OAR::IO::sql_to_local($types->{expire});
        if ($scheduler_init_date > $expire_time_sec) {
            oar_debug("[$scheduler_name] [$j->{job_id}] job will never run (expire=$types->{expire}), setting it to error\n");
            OAR::IO::set_job_message($base, $j->{job_id}, "job canceled because expired");
            OAR::IO::set_job_state($base, $j->{job_id}, "toError");
            next;
        }
    }

    my $deadline_time_sec;
    if (defined($types->{deadline})) {
        $deadline_time_sec = OAR::IO::sql_to_local($types->{deadline});
        if ($scheduler_init_date > $deadline_time_sec) {
            oar_debug("[$scheduler_name] [$j->{job_id}] job will never run (deadline=$types->{deadline}), setting it to error\n");
            OAR::IO::set_job_message($base, $j->{job_id}, "job canceled because of its deadline");
            OAR::IO::set_job_state($base, $j->{job_id}, "toError");
            next;
        }
    }

    # Search for dependencies
    my $skip_job = 0;

    # Check the job dependencies 
    foreach my $d (OAR::IO::get_current_job_dependencies($base,$i)){
        next if ($skip_job == 1);
        my $dep_job = OAR::IO::get_job($base,$d->[0]);
        if (($dep_job->{state} ne "Terminated") and ($dep_job->{state} ne "Error")){
            my @date_tmp = OAR::IO::get_gantt_job_start_time($base,$d);
            if (defined($date_tmp[0])){
                my $mold_dep = OAR::IO::get_current_moldable_job($base,$date_tmp[1]);
                my $sched_tmp = $date_tmp[0] + $mold_dep->{moldable_walltime} - $d->[1];
                if ($scheduler_init_date < $sched_tmp){
                    if ($d->[1] > 0) {
                        $scheduler_init_date = $sched_tmp;
                    } else {
                        $scheduler_init_date = $sched_tmp + (2 * $security_time_overhead);
                    }
                }
            }else{
                my $message = "Cannot determine scheduling time due to dependency with the job $d";
                OAR::IO::set_job_message($base,$i,$message);
                oar_debug("[$scheduler_name] [$i] $message\n");
                $skip_job = 1;
                next;
            }
        }elsif (($dep_job->{job_type} eq "PASSIVE") and ($dep_job->{exit_code} != 0)){
            my $message = "Cannot determine scheduling time due to dependency with the job $d (exit code != 0)";
            OAR::IO::set_job_message($base,$i,$message);
            OAR::IO::set_job_scheduler_info($base,$i,$message);
            oar_debug("[$scheduler_name] [$i] $message\n");
            $skip_job = 1;
            next;
        }
    }
    next if ($skip_job == 1);

    my $gantt_name = "default";
    my $placeholder_name = "";
    my $allowed_name = "";
    my $timesharing_user = "";
    my $timesharing_name = "";
    my $types = OAR::IO::get_job_types_hash($base,$i);
    my @type_list = sort(keys(%{$types}));
    if (defined($types->{inner})) {
        $gantt_name = "container:$types->{inner}";
        if (not defined($Gantt->{$gantt_name})){
            oar_debug("[$scheduler_name] [$i] inner job, wants to use gantt: ($gantt_name,...) which does not exist. Skipped\n");
            OAR::IO::set_job_message($base,$i,"$gantt_name does not exist, skipped");
            OAR::IO::set_job_scheduler_info($base,$i,"$gantt_name does not exist, skipped");
            next;
        }
    } elsif (defined($types->{constraints}) and not exists($constraints->{$types->{constraints}})) {
        my ($r, $max_constraint_duration) = OAR::Schedulers::Gantt::compute_constraints($types->{constraints}, $scheduler_init_date, $Constraints_iterations);
        $constraints->{$types->{constraints}} = $r;
        # Job cannot be scheduler if job duration does not fit in any constraint
        #if ($duration < $max_constraint_duration) {
        #    my $message = "job duration cannot fit in constraints. Skipped";
        #    oar_debug("[$scheduler_name] [$i] $message\n");
        #    OAR::IO::set_job_message($base,$i,$message);
        #    OAR::IO::set_job_scheduler_info($base,$i,$message);
        #    next;
        #}
    }
    if (defined($types->{container})){ # A container job cannot be placeholder or allowed or timesharing. 
        oar_debug("[$scheduler_name] [$i] job is ($gantt_name,,,) and is a container\n");
        # nothing more to do, Gantt for container will be created once the job is scheduled, below.
    } else {
        ($gantt_name, $placeholder_name, $allowed_name, $timesharing_name, $timesharing_user) =
            OAR::Schedulers::Gantt::manage_gantt_hierarchy($Gantt, $j->{job_name}, $j->{job_user}, $types, $constraints, "[$scheduler_name] [$i]");
    }
    if (defined($types->{token})){
        foreach my $t (keys(%{$types->{token}})){
            next if ($skip_job == 1);
            oar_debug("[$scheduler_name] [$j->{job_id}] Check token: $t ($types->{token}->{$t}).\n");
            # Check if we must execute the corresponding script
            if ((!defined($Token_values{$t})) and (defined($Token_scripts->{$t}))){
                oar_debug("[$scheduler_name] [$j->{job_id}] Execute $Token_scripts->{$t}\n");
                if (open(TOKSCRIPT, "$Token_scripts->{$t} |")){
                    my $num = <TOKSCRIPT>;
                    chop($num);
                    if ($num =~ /^\d+$/){
                        $Token_values{$t} = $num;
                        oar_debug("[$scheduler_name] [$j->{job_id}]  $Token_scripts->{$t} returns $num\n");
                    }else{
                        oar_warn("[$scheduler_name] [$j->{job_id}] The token script $Token_scripts->{$t} does not return a number ($num).\n");
                    }
                    close(TOKSCRIPT);
                }
            }
            if (defined($Token_values{$t})){
                if ($Token_values{$t} < $types->{token}->{$t}){
                    oar_debug("[$scheduler_name] [$j->{job_id}] No enough Tokens: $t ($Token_values{$t} < $types->{token}->{$t}).\n");
                    OAR::IO::set_job_message($base,$j->{job_id},"No enough Token: $t ($Token_values{$t} < $types->{token}->{$t})");
                    #OAR::IO::set_job_scheduler_info($base,$j->{job_id},"No enough Token: $t ($Token_values{$t} < $types->{token}->{$t})");
                    $skip_job = 1;
                }
            }else{
                oar_debug("[$scheduler_name] [$j->{job_id}] Token value cannot be retrieved ($t).\n");
                OAR::IO::set_job_message($base,$j->{job_id},"Token value cannot be retrieved ($t)");
                #OAR::IO::set_job_scheduler_info($base,$j->{job_id},"Token value cannot be retrieved ($t)");
                $skip_job = 1;
            }
        }
        next if ($skip_job == 1);
    }
    #OAR::Schedulers::Gantt::pretty_print($gantt_to_use);
    #oar_debug("[$scheduler_name] [$j->{job_id}] Gantt data structure:\n".OAR::Schedulers::Gantt::pretty_print($gantt_to_use));

    my $job_properties = "\'1\'";
    if ((defined($j->{properties})) and ($j->{properties} ne "")){
        $job_properties = $j->{properties};
    }
    
    # Choose the moldable job to schedule
    my @moldable_results;
    my $job_descriptions = OAR::IO::get_resources_data_structure_current_job($base,$i);
    foreach my $moldable (@{$job_descriptions}){
        my $duration;
        if (defined($types->{besteffort})){
            $duration = $besteffort_duration;
        }else{
            $duration = $moldable->[1] + $security_time_overhead;
        }

        my @tree_list;
        foreach my $m (@{$moldable->[0]}){
            my $tmp_properties = "\'1\'";
            if ((defined($m->{property})) and ($m->{property} ne "")){
                $tmp_properties = $m->{property};
            }
            my $tmp_tree = OAR::IO::get_possible_wanted_resources($base_ro,$alive_resources_vector,undef,\@Dead_resources,"$job_properties AND $tmp_properties", $m->{resources}, $Order_part);
            push(@tree_list, $tmp_tree);
        }
        my $gantt_timeout =  ($timeout - (time() - $initial_time)) / 4;
        $gantt_timeout = $Minimum_timeout_per_job if ($gantt_timeout <= ($timeout / 8));
        oar_debug("[$scheduler_name] [$i] find_first_hole in gantt ($gantt_name,$allowed_name,$timesharing_name,$timesharing_user) with a timeout of $gantt_timeout\n");
        my @hole = OAR::Schedulers::Gantt::find_first_hole(
            $Gantt->{$gantt_name}->{$allowed_name}->{$timesharing_name}->{$timesharing_user},
            $scheduler_init_date,
            $duration,
            \@tree_list,
            $gantt_timeout,
            $j->{queue_name},
            $j->{project},
            \@type_list,
            $j->{job_user},
            $Gantt_quotas,
            $quota_accounting_data,
            $Only_default_type_resource_vec
            );
        # Free memory
        foreach my $t (@tree_list){
            OAR::Schedulers::ResourceTree::destroy($t);
        }
        my @resources;
        my $res_vec = '';
        foreach my $t (@{$hole[2]}){
            $res_vec |= $t->[1];
            push(@resources, @{$t->[2]});
            OAR::Schedulers::ResourceTree::destroy($t->[0]);
        }
        push(@moldable_results, {
                                    resources => \@resources,
                                    resources_vec => $res_vec,
                                    start_time => $hole[0],
                                    duration => $duration,
                                    moldable_id => $moldable->[2],
                                    walltime => $moldable->[1],
                                    comment => $hole[1]
                                });
    }

    # Choose moldable job which will finish the first
    my $index_to_choose = -1;
    my $best_stop_time;
    for (my $i=0; $i <= $#moldable_results; $i++){
        if ($#{$moldable_results[$i]->{resources}} >= 0){
            my $tmp_stop_date = $moldable_results[$i]->{start_time} + $moldable_results[$i]->{duration};
            if ((!defined($best_stop_time)) or ($best_stop_time > $tmp_stop_date)){
                $best_stop_time = $tmp_stop_date;
                $index_to_choose = $i;
            }
        }
    }
    if ($index_to_choose >= 0){
        if (defined($deadline_time_sec) and $best_stop_time > $deadline_time_sec) {
            oar_debug("[$scheduler_name] [$j->{job_id}] not scheduling job because its deadline is not met: $best_stop_time > $deadline_time_sec\n");
            next;
        }
        # We can schedule the job
        oar_debug("[$scheduler_name] [$i] job is successfully scheduled\n");
        # Create gantt for the new container
        if (defined($types->{container})){
            my $container_name;
            if ($types->{container} ne "true") { 
                $container_name = "container:$types->{container}";
            } else {
                $container_name = "container:$i";
            }
            if (defined($Gantt->{$container_name})) {
                oar_debug("[$scheduler_name] [$i] container job, adding a hole in gantt: ($container_name,,,)\n");
                $Gantt->{$container_name}->{""}->{""}->{""} = OAR::Schedulers::Gantt::add_1_hole($Gantt->{$container_name}->{""}->{""}->{""}, $moldable_results[$index_to_choose]->{start_time}, $moldable_results[$index_to_choose]->{duration}, $moldable_results[$index_to_choose]->{resources_vec});
            } else {
                oar_debug("[$scheduler_name] [$i] container job, creating gantt: ($container_name,,,)\n");
                $Gantt->{$container_name}->{""}->{""}->{""} = OAR::Schedulers::Gantt::new_with_1_hole($Max_resources, $minimum_hole_time, $moldable_results[$index_to_choose]->{start_time}, $moldable_results[$index_to_choose]->{duration}, $moldable_results[$index_to_choose]->{resources_vec}, $All_resource_list_vec);
            }
        }else{
            OAR::Schedulers::Quotas::update_accounting_counters(
                                               $quota_accounting_data,
                                               unpack("%32b*",$moldable_results[$index_to_choose]->{resources_vec} & $Only_default_type_resource_vec),
                                               $moldable_results[$index_to_choose]->{start_time},
                                               $moldable_results[$index_to_choose]->{duration},
                                               $j->{queue_name},
                                               $j->{project},
                                               \@type_list,
                                               $j->{job_user}
                                             );
            #oar_debug("[$scheduler_name] [$j->{job_id}] ".OAR::Schedulers::Quotas::pretty_print($quota_accounting_data));
        }

        #Fill all other gantts
        OAR::Schedulers::Gantt::fill_gantt_hierarchy($Gantt, $moldable_results[$index_to_choose]->{start_time}, $moldable_results[$index_to_choose]->{duration}, $moldable_results[$index_to_choose]->{resources_vec}, $gantt_name, $placeholder_name, $timesharing_name, $timesharing_user, "[$scheduler_name] [$i]"); 

        #update database
        push(@{$moldable_results[$index_to_choose]->{resources}},@Resources_to_always_add);
        OAR::IO::add_gantt_scheduled_jobs($base,$moldable_results[$index_to_choose]->{moldable_id}, $moldable_results[$index_to_choose]->{start_time},$moldable_results[$index_to_choose]->{resources});

        # Feed message job field
        my $message = OAR::IO::format_job_message_text($j->{job_name},$#{$moldable_results[$index_to_choose]->{resources}}+1,$moldable_results[$index_to_choose]->{walltime},$j->{job_type},$j->{reservation},$j->{queue_name},$j->{project},\@type_list,"Karma=".sprintf("%.3f",karma($j)).",$moldable_results[$index_to_choose]->{comment}");
        OAR::IO::set_job_message($base,$j->{job_id},$message);
        #OAR::IO::set_job_scheduler_info($base,$j->{job_id},"Karma = ".sprintf("%.3f",karma($j)));

        # Update Token values
        if (defined($types->{token}) and ($moldable_results[$index_to_choose]->{start_time} <= $current_time)){
            foreach my $t (keys(%{$types->{token}})){
                $Token_values{$t} = $Token_values{$t} - $types->{token}->{$t};
                oar_debug("[$scheduler_name] Update TOKEN $t to $Token_values{$t}\n");
            }
        }

        if ($moldable_results[$index_to_choose]->{start_time} <= $current_time){
            # Try tu run the job now
            print("SCHEDRUN JOB_ID=$j->{job_id} MOLDABLE_JOB_ID=$moldable_results[$index_to_choose]->{moldable_id} RESOURCES=".join(',', @{$moldable_results[$index_to_choose]->{resources}})."\n");
        }
    }elsif ($moldable_results[0]->{comment} ne "TIMEOUT"){
        my $message = "No enough matching resources ($moldable_results[0]->{comment})";
        OAR::IO::set_job_message($base,$j->{job_id},$message);
        #OAR::IO::set_job_scheduler_info($base,$j->{job_id},$message);
        oar_debug("[$scheduler_name] [$j->{job_id}] $message\n");
    }
    oar_debug("[$scheduler_name] [$i] end scheduling\n");
}
oar_debug("[$scheduler_name] End phase 2 (waiting jobs)\n");


OAR::IO::disconnect($base);
OAR::IO::disconnect($base_ro);

if ($job_index <= $#jobs){
    oar_debug("[$scheduler_name] Warning: some jobs were not scheduled because the scheduler reached its timeout ($timeout s)\n");
}

oar_debug("[$scheduler_name] End of scheduler for queue $queue\n");

