#!/usr/bin/perl
# $Id: oar_meta_sched,v 1.31 2005/02/16 18:47:10 capitn Exp $

use strict;
use warnings;
use DBI();
use oar_iolib;
use oar_Judas qw(oar_debug oar_warn oar_error);
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use Data::Dumper;
use oar_scheduler;
use oar_Tools;


my $exit_code = 0;
my $base = iolib::connect();
my $base_ro = iolib::connect_ro();

init_conf($ENV{OARCONFFILE});
my $security_time_overhead = 1;
if (is_conf("SCHEDULER_JOB_SECURITY_TIME")){
    $security_time_overhead = get_conf("SCHEDULER_JOB_SECURITY_TIME");
}

my $minimum_hole_time = 0;
if (is_conf("SCHEDULER_GANTT_HOLE_MINIMUM_TIME")){
    $minimum_hole_time = get_conf("SCHEDULER_GANTT_HOLE_MINIMUM_TIME");
}

my $Order_part = get_conf("SCHEDULER_RESOURCE_ORDER");

my $binpath;
if (defined($ENV{OARDIR})){
    $binpath = $ENV{OARDIR}."/";
}else{
    die("[MetaSched] OARDIR env variable must be defined\n");
}

oar_debug("[MetaSched] Start of meta scheduler\n");

oar_scheduler::init_scheduler($base,$base_ro,$security_time_overhead,$minimum_hole_time,$Order_part);

my %initial_time = oar_scheduler::get_initial_time();
my @queues = iolib::get_active_queues($base);
my $name;
my $policy;
foreach my $i (@queues){
    $name = $i->[0];
    $policy = $i->[1];
    my $waiting_jobs = iolib::is_waiting_job_specific_queue_present($base,$name);
    if ($waiting_jobs == 1){
        oar_debug("[MetaSched] Launching scheduler $name with $policy at time $initial_time{sql}\n");
        my ($sched_exit_code,$sched_signal_num,$sched_dumped_core) = oar_Tools::launch_command("$binpath/$policy $name $initial_time{sec} \"$initial_time{sql}\"");
        if (($sched_signal_num != 0) || ($sched_dumped_core != 0)){
            oar_error("[MetaSched] Something wrong occured, we inactive the queue $name (signal or core dumped or '$binpath/$policy' cannot be executed)!!! Look at 'oarnotify' if you want to change queue settings.\n");
            iolib::stop_a_queue($base,$name);
        }
        if ($sched_exit_code == 1){
            $exit_code = 1;
        }elsif($sched_exit_code != 0){
            oar_error("[MetaSched] Scheduler $binpath/$policy on queue $name at time $initial_time{sec} returns a bad value : $sched_exit_code. So this queue will be disabled (look at 'oarnotify' if you want to change queue settings).\n");
            #$exit_code = 3;
        }
        if (oar_scheduler::treate_waiting_reservation_jobs($base,$name) != 0){
            $exit_code = 1;
        }
        if (oar_scheduler::check_reservation_jobs($base,$base_ro,$name,$Order_part) != 0){
            $exit_code = 1;
        }
    }else{
        oar_debug("[MetaSched] No waiting job in $name queue\n");
    }
}

if ($exit_code == 0){
    if (oar_scheduler::check_jobs_to_kill($base) == 1){
        # We must kill besteffort jobs
        $exit_code = 2;
    }elsif (oar_scheduler::check_jobs_to_launch($base) == 1){
        $exit_code = 1;
    }
}

#Update visu gantt tables
oar_scheduler::update_gantt_visu_tables($base);
iolib::disconnect($base_ro);

if (is_conf("SCHEDULER_NODE_MANAGER_SLEEP_CMD") and is_conf("SCHEDULER_NODE_MANAGER_SLEEP_TIME") and is_conf("SCHEDULER_NODE_MANAGER_IDLE_TIME")){
    my @node_halt= oar_scheduler::get_idle_nodes(
            $base,
            get_conf("SCHEDULER_NODE_MANAGER_IDLE_TIME"),
            get_conf("SCHEDULER_NODE_MANAGER_SLEEP_TIME")
        );
    if ($#node_halt >= 0){
        oar_debug("[MetaSched] Some nodes can be halted : @node_halt\n");
        oar_Tools::fork_no_wait(get_conf("SCHEDULER_NODE_MANAGER_SLEEP_CMD")." @node_halt", $base);
    }
}

if (is_conf("SCHEDULER_NODE_MANAGER_WAKE_UP_CMD")){
    # Wake up right nodes
    my @nodes = oar_scheduler::get_nodes_to_wake_up($base);

    if ($#nodes >= 0){
        oar_debug("[MetaSched] Some nodes must be started : @nodes\n");
        oar_Tools::fork_no_wait(get_conf("SCHEDULER_NODE_MANAGER_WAKE_UP_CMD")." @nodes", $base);
    }
}

iolib::disconnect($base);
oar_debug("[MetaSched] End of meta scheduler\n");

exit($exit_code);
