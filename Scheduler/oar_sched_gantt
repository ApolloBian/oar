#!/usr/bin/perl

use strict;
use DBI();
use oar_iolib;
use Data::Dumper;
use oar_Judas qw(oar_debug oar_warn oar_error);
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use Gantt;

my $initial_time = time();
my $timeout = 10;
init_conf("oar.conf");
if (is_conf("SCHEDULER_TIMEOUT")){
    $timeout = get_conf("SCHEDULER_TIMEOUT");
}

# Constant duration time of a besteffort job
my $besteffort_duration = 5*60;

# $security_time_overhead is the security time (second) used to be sure there
# are no problem with overlaping jobs
my $security_time_overhead = 1;

my $current_time ;

my $queue;
if (defined($ARGV[0]) && defined($ARGV[1]) && $ARGV[1] =~ m/\d+/m) {
    $queue = $ARGV[0];
    $current_time = $ARGV[1];
}else{
    oar_error("[oar_sched_gant] no queue specified on command line\n");
    exit(1);
}

# Init
my $base = iolib::connect();

oar_debug("[oar_sched_gant] Begining of Gantt scheduler on queue $queue at time $current_time\n");

# Create the Gantt Diagram
my $gantt = Gantt::new();
#Init the gantt chart with all resources
foreach my $r (iolib::list_resources($base)){
    Gantt::add_new_resource($gantt, $r->{resourceId});
}

# Take care of currently scheduled jobs (gantt in the database)
my %alreadyScheduledJobs = iolib::get_gantt_scheduled_jobs($base);
foreach my $i (keys(%alreadyScheduledJobs)){
    # Do not take care of besteffort jobs
    my $types = iolib::get_current_job_types($base,$i);
    if (!defined($types->{"besteffort"})){
        foreach my $r (@{$alreadyScheduledJobs{$i}->[3]}){
            Gantt::set_occupation(  $gantt,
                                    iolib::sql_to_local($alreadyScheduledJobs{$i}->[0]),
                                    iolib::sql_to_duration($alreadyScheduledJobs{$i}->[1]) + $security_time_overhead,
                                    $r
                                 );
        }
    }
}

print(Gantt::pretty_print($gantt)."\n");

# End of the initialisation
# Begining of the real scheduling

my @jobs = iolib::get_jobs_to_schedule($base,$queue);
my $job_index = 0;
while (($job_index <= $#jobs) and ((time() - $initial_time) < $timeout)){
    my $j = $jobs[$job_index];
    $job_index ++;
    # Choose the moldable job to schedule
    # Here we make it simple, we choose the first
    my $job_descriptions = iolib::get_resources_data_structure_current_job($base,$j->{idJob});
    my $moldable = $job_descriptions->[0];
    
    my $types = iolib::get_current_job_types($base,$j->{idJob});
    my $duration = iolib::sql_to_duration($moldable->[1]);
    if (defined($types->{"besteffort"})){
        $duration = $besteffort_duration;
    }
    
    # Get list of Alive resources
    my @alive_resources;
    foreach my $r (iolib::get_resources_in_state($base,"Alive")){
        push(@alive_resources, $r->{resourceId});
    }
    
    my $job_properties = "TRUE";
    if ($j->{properties} ne ""){
        $job_properties = $j->{properties};
    }

    my @resource_id_used_list;
    my @tree_list;
    foreach my $m (@{$moldable->[0]}){
        my $tmp_properties = "TRUE";
        if ($m->{property} ne ""){
            $tmp_properties = $m->{property};
        }
        my $tmp_tree = iolib::get_possible_wanted_resources($base,\@alive_resources,\@resource_id_used_list,"$job_properties AND $tmp_properties", $m->{resources});
        push(@tree_list, $tmp_tree);
        my @leafs = oar_resource_tree::get_tree_leafs($tmp_tree);
        foreach my $l (@leafs){
            push(@resource_id_used_list, oar_resource_tree::get_current_resource_value($l));
        }
    }
    my @hole = Gantt::find_first_hole($gantt,$current_time, $duration, \@tree_list);
    my @res_trees;
    my @resources;
    foreach my $t (@{$hole[1]}){
        my $minimal_tree = oar_resource_tree::delete_unnecessary_subtrees($t);
        push(@res_trees, $minimal_tree);
        foreach my $r (oar_resource_tree::get_tree_leafs($minimal_tree)){
            push(@resources, oar_resource_tree::get_current_resource_value($r));
        }
    }

    if ($#resources >= 0){
        # We can schedule the job
        foreach my $r (@resources){
            Gantt::set_occupation($gantt, $hole[0], $duration, $r);
        }
        #update database
        my ($year,$mon,$day,$hour,$min,$sec) = iolib::local_to_ymdhms($hole[0]);
        iolib::add_gantt_scheduled_jobs($base,$moldable->[2],"$year-$mon-$day $hour:$min:$sec",\@resources);
    }
}

iolib::disconnect($base);
oar_debug("[oar_sched_gant] End of scheduler for queue $queue\n");

