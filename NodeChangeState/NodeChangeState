#!/usr/bin/perl
# $Id: NodeChangeState,v 1.11 2005/10/03 14:36:36 capitn Exp $
#Almighty module which changes node state

use English;
use oar_iolib;
use Data::Dumper;
use oar_Judas qw(oar_debug oar_warn oar_error);
use IO::Socket::INET;
use strict;

my $Exit_code = 0;

my $base = iolib::connect();

iolib::lock_table($base,["resources","assigned_resources","jobs","job_state_logs","event_logs","event_log_hostnames","frag_jobs","moldable_job_descriptions","challenges","job_types","job_dependencies","job_resource_groups","job_resource_descriptions","resource_logs"]);

# Check event logs
my @events_to_check = iolib::get_to_check_events($base);
foreach my $i (@events_to_check){
    oar_debug("[NodeChangeState] Check event for the job $i->{job_id} with type $i->{type}\n");
    
    #########################################
    # Check if we must change the job state #
    #########################################
    if (
        ($i->{type} eq "PING_CHECKER_NODE_SUSPECTED") ||
        ($i->{type} eq "CPUSET_ERROR") ||
        ($i->{type} eq "PROLOGUE_ERROR") ||
        ($i->{type} eq "CANNOT_WRITE_NODE_FILE") ||
        ($i->{type} eq "CANNOT_WRITE_PID_FILE") ||
        ($i->{type} eq "USER_SHELL") ||
        ($i->{type} eq "EXTERMINATE_JOB") ||
        ($i->{type} eq "CANNOT_CREATE_TMP_DIRECTORY") ||
        ($i->{type} eq "LAUNCHING_OAREXEC_TIMEOUT") ||
        ($i->{type} eq "RESERVATION_NO_NODE") ||
        ($i->{type} eq "EXIT_VALUE_OAREXEC")
       ){
        my $job = iolib::get_job($base,$i->{job_id});
        if (($job->{reservation} eq "None") or ($job->{type} eq "RESERVATION_NO_NODE")){
            iolib::set_job_state($base,$i->{job_id},"Error");
        }
    }
    
    if (
        ($i->{type} eq "CPUSET_CLEAN_ERROR") ||
        ($i->{type} eq "EPILOGUE_ERROR")
       ){
        # At this point the job was executed normally
        # The state is changed here to avoid to schedule other jobs
        # on nodes that will be Suspected
        iolib::set_job_state($base,$i->{job_id},"Terminated");
    }
    
    #######################################
    # Check if we must suspect some nodes #
    #######################################
    if (($i->{type} eq "PING_CHECKER_NODE_SUSPECTED") ||
        ($i->{type} eq "CPUSET_ERROR") ||
        ($i->{type} eq "CPUSET_CLEAN_ERROR") ||
        ($i->{type} eq "PROLOGUE_ERROR") ||
        ($i->{type} eq "EPILOGUE_ERROR") ||
        ($i->{type} eq "CANNOT_WRITE_NODE_FILE") ||
        ($i->{type} eq "CANNOT_WRITE_PID_FILE") ||
        ($i->{type} eq "USER_SHELL") ||
        ($i->{type} eq "EXTERMINATE_JOB") ||
        ($i->{type} eq "CANNOT_CREATE_TMP_DIRECTORY") ||
        ($i->{type} eq "LAUNCHING_OAREXEC_TIMEOUT") ||
        ($i->{type} eq "EXIT_VALUE_OAREXEC")
       ){
        my @hosts;
        my $finaud_tag;
        # Restrict Suspected state to the first node (node really connected with OAR) for some event types
        if (($i->{type} eq "PING_CHECKER_NODE_SUSPECTED") ||
            ($i->{type} eq "CPUSET_ERROR") ||
            ($i->{type} eq "CPUSET_CLEAN_ERROR")){
            @hosts = iolib::get_hostname_event($base,$i->{event_id});
            $finaud_tag = "YES" if ($i->{type} eq "PING_CHECKER_NODE_SUSPECTED");
        }else{
            my $job = iolib::get_job($base,$i->{job_id});
            @hosts = iolib::get_job_host_log($base,$job->{assigned_moldable_job});
            $finaud_tag = "NO";
            if (($i->{type} ne "EXTERMINATE_JOB")){
                @hosts = ($hosts[0]);
            }
        }

        my %already_treated_host;
        foreach my $j (@hosts){
            next if ((defined($already_treated_host{$j}) or ($j eq "")));
            $already_treated_host{$j} = 1;
            my @free_resources = iolib::get_current_free_resources_of_node($base, $j);
            if ($#free_resources >= 0){
                oar_warn("[NodeChangeState] There was an error ($i->{type}) on the node $j SO we are suspecting resource(s) : @free_resources\n");
                foreach my $r (@free_resources){
                    iolib::set_node_state($base,$j,"Suspected",$finaud_tag);
                    $Exit_code = 1;
                }
            }else{
                oar_warn("[NodeChangeState] There was an error ($i->{type}) on the node $j BUT we cannot Suspect this node because all resources are busy\n");
            }
        }
    }
    
    ########################################
    # Check if we must stop the scheduling #
    ########################################
    if (
        ($i->{type} eq "SERVER_PROLOGUE_TIMEOUT") ||
        ($i->{type} eq "SERVER_PROLOGUE_EXIT_CODE_ERROR") ||
        ($i->{type} eq "SERVER_PROLOGUE_ERROR") ||
        ($i->{type} eq "SERVER_EPILOGUE_TIMEOUT") ||
        ($i->{type} eq "SERVER_EPILOGUE_EXIT_CODE_ERROR") ||
        ($i->{type} eq "SERVER_EPILOGUE_ERROR")
       ){
        oar_warn("[NodeChangeState] Server admin script error so we stop all scheduling queues : $i->{type}. When the error will be fixed then you can execute : oarnotify -Q\n");
        iolib::stop_all_queues($base);
        iolib::set_job_state($base,$i->{job_id},"Error");
    }

    #####################################
    # Check if we must resubmit the job #
    #####################################
    if (
        ($i->{type} eq "SERVER_PROLOGUE_TIMEOUT") ||
        ($i->{type} eq "SERVER_PROLOGUE_EXIT_CODE_ERROR") ||
        ($i->{type} eq "SERVER_PROLOGUE_ERROR") ||
        ($i->{type} eq "PING_CHECKER_NODE_SUSPECTED") ||
        ($i->{type} eq "CPUSET_ERROR") ||
        ($i->{type} eq "PROLOGUE_ERROR") ||
        ($i->{type} eq "CANNOT_WRITE_NODE_FILE") ||
        ($i->{type} eq "CANNOT_WRITE_PID_FILE") ||
        ($i->{type} eq "USER_SHELL") ||
        ($i->{type} eq "CANNOT_CREATE_TMP_DIRECTORY") ||
        ($i->{type} eq "LAUNCHING_OAREXEC_TIMEOUT")
       ){
        my $job = iolib::get_job($base,$i->{job_id});
        if (($job->{reservation} eq "None") and ($job->{job_type} eq "PASSIVE") and (iolib::is_job_already_resubmitted($base, $i->{job_id}) == 0)){
            my $new_job_id = iolib::resubmit_job($base,$i->{job_id});
            oar_warn("[NodeChangeState] We resubmit the job $i->{job_id} (new id = $new_job_id) because the event was $i->{type} and the job is neither a reservation nor an interactive job.\n");
            iolib::add_new_event($base,"RESUBMIT_JOB_AUTOMATICALLY",$i->{job_id},"An ERROR occured and we cannot launch this job so we resubmit it (new id = $new_job_id).");
        }
    }

    ####################################
    # Check Suspend/Resume job feature #
    ####################################
    if (
        ($i->{type} eq "HOLD_WAITING_JOB") ||
        ($i->{type} eq "HOLD_RUNNING_JOB") ||
        ($i->{type} eq "RESUME_JOB")
       ){
        my $job = iolib::get_job($base,$i->{job_id});
        if ((($i->{type} eq "HOLD_WAITING_JOB") or ($i->{type} eq "HOLD_RUNNING_JOB")) and (($job->{state} eq "Waiting"))){
            iolib::set_job_state($base,$i->{job_id},"Hold");
        }elsif (($i->{type} eq "HOLD_RUNNING_JOB") and ($job->{state} eq "Running")){
            # Launch suspend command on all nodes

            iolib::set_job_state($base,$i->{job_id},"Suspended");
        }elsif (($i->{type} eq "RESUME_JOB") and ($job->{state} eq "Suspended")){
            iolib::set_job_state($base,$i->{job_id},"Resuming");
        }
    }
   
    iolib::check_event($base, $i->{type}, $i->{job_id});
}


# Treate nextState field
my %resources_to_change = iolib::get_resources_change_state($base);

#A Term command must be added in the Almighty
oar_debug("[NodeChangeState] number of resources to change state = ".keys(%resources_to_change)."\n");
if (keys(%resources_to_change) > 0){
    $Exit_code = 1;
}

foreach my $i (keys(%resources_to_change)){
    my $resource_info = iolib::get_resource_info($base,$i);
    if ($resource_info->{state} ne $resources_to_change{$i}){
        if ($resource_info->{next_finaud_decision} eq "YES"){
            oar_warn("[NodeChangeState] Finaud is automatically changing the state of the resource $i into $resources_to_change{$i}\n");
        }else{
            oar_warn("[NodeChangeState] $i --> $resources_to_change{$i}\n");
        }

        iolib::set_resource_state($base,$i,$resources_to_change{$i},$resource_info->{next_finaud_decision});
        iolib::set_resource_nextState($base,$i,'UnChanged');

        if (($resources_to_change{$i} eq 'Dead') || ($resources_to_change{$i} eq 'Absent')){
            oar_debug("[NodeChangeState] Check jobs to delete on $i :\n");
            my @jobs = iolib::get_resource_job($base,$i);
            foreach my $j (@jobs){
                oar_debug("[NodeChangeState]\tThe job $j is fragging.\n");
                iolib::frag_job($base,$j);
                # A Leon must be run
                $Exit_code = 2;
            }
            oar_debug("[NodeChangeState] Check done\n");
        }
    }else{
        oar_warn("[NodeChangeState] $i is already in the $resources_to_change{$i} state\n");
        iolib::set_resource_nextState($base,$i,'UnChanged');
    }
}
iolib::unlock_table($base);
iolib::disconnect($base);

exit($Exit_code);
