#!/usr/bin/perl

use oar_iolib;
use Sys::Hostname;
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use oar_Judas qw(oar_debug oar_warn oar_error);
use ping_checker;
use oar_Tools;
use Data::Dumper;
use IPC::Open2;

my $Job_id= shift;
my $Oarexec_reattach_exit_value = shift;
my $Oarexec_challenge = shift;

#get server conf
init_conf("oar.conf");
my $Remote_host = get_conf("SERVER_HOSTNAME");
my $Remote_port = get_conf("SERVER_PORT");

my $Almighty_hostname = $Remote_host;
if (($Almighty_hostname =~ /^\s*localhost.*$/) or ($Almighty_hostname =~ /^\s*127.*$/)){
    $Almighty_hostname = hostname();
}

my $Deploy_hostname = get_conf("DEPLOY_HOSTNAME");
if (!defined($Deploy_hostname)){
    $Deploy_hostname = $Remote_host;
}
my $Debug_mode = get_conf("OAREXEC_DEBUG_MODE");
if (!defined($Debug_mode)){
    $Debug_mode = 0;
}

my $Detach_oarexec = get_conf("DETACH_JOB_FROM_SERVER");
if (!defined($Detach_oarexec)){
    $Detach_oarexec = 0;
}


my $Server_prologue = get_conf("SERVER_PROLOGUE_EXEC_FILE");
my $Server_epilogue = get_conf("SERVER_EPILOGUE_EXEC_FILE");

my $base;

$base = iolib::connect();

my $job = iolib::get_job($base,$Job_id);
my $job_challenge = iolib::get_job_challenge($base,$Job_id);

my @hosts = iolib::get_job_current_hostnames($base,$Job_id);

if($#hosts < 0){
    oar_error("[bipbip $Job_id] A Job is requested on NO HOSTS. This job must be already killed (exterminated) and come back from hell ???\n");
    iolib::add_new_event($base, "BIPBIP_BAD_JOBID", $Job_id, "A Job is requested on NO HOSTS. This job must be already killed (exterminated) and come back from hell ???");
    iolib::disconnect($base);
    exit 1;
}

my $host_to_connect_via_ssh = $hosts[0];
#deploy part
my $types = iolib::get_current_job_types($base,$Job_id);
if (defined($types->{deploy})){
    $host_to_connect_via_ssh = $Deploy_hostname;
}
#deploy part

#check if we must treate the end of a oarexec
if (defined($Oarexec_reattach_exit_value)){
    if ($Oarexec_reattach_exit_value =~ m/\d+/m){
        if ($Oarexec_challenge eq $job_challenge){
            iolib::check_end_of_job($base, $Job_id, $Oarexec_reattach_exit_value, \@hosts, $Remote_host, $Remote_port,$job->{job_user},$job->{launching_directory},$Server_epilogue);
            iolib::disconnect($base);
            exit(0);
        }else{
            oar_error("[bipbip $Job_id] Bad challenge from oarexec, perhaps a pirate attack??? ($Oarexec_challenge).\n");
            iolib::add_new_event($base, "BIPBIP_CHALLENGE", $Job_id, "Bad challenge from oarexec, perhaps a pirate attack??? ($Oarexec_challenge)");
            iolib::disconnect($base);
            exit(2);
        }
    }else{
        oar_error("[bipbip $Job_id] Bad argument for bipbip : $Oarexec_reattach_exit_value\n");
        iolib::disconnect($base);
        exit(2);
    }
}

# ELSE we must launch oarexec on the first node
oar_debug("[bipbip $Job_id] JOB: $Job_id; User: $job->{job_user}; Command: $job->{command} ==> hosts :[@hosts]\n");


# CHECK nodes
oar_debug("[bipbip $Job_id] Check nodes : @hosts\n");
my @bad = ping_checker::test_hosts(@hosts);
if ($#bad >= 0){
    iolib::lock_table($base,["jobs","job_state_logs","resources","assigned_resources","frag_jobs","resource_state_logs","challenges","moldable_job_descriptions","job_types","job_dependencies","job_resource_groups","job_resource_descriptions"]);
    iolib::set_job_message($base,$Job_id,"One or several nodes are not responding");
    oar_error("[bipbip $Job_id] /!\\ Sorry but some nodes are inaccessible : @bad\n");
    if ($job->{job_type} eq "INTERACTIVE"){
        my ($addr,$port) = split(/:/,$job->{info_type});
        oar_Tools::notify_tcp_socket($addr,$port,"INVALID RESOURCES : some resources did not respond");
    }else{
        # Resubmit this passive job
        my $new_job_id = iolib::resubmit_job($base, $job->{job_id});
        add_new_event($base,"RESUBMIT_JOB_AUTOMATICALLY",$job->{job_id},"Some resources are not responding and this is a PASSIVE job so I resubmit it (new id = $new_job_id).");
    }
    iolib::set_job_state($base,$Job_id,"Error");
    iolib::add_new_event_with_host($base,"PING_CHECKER_NODE_SUSPECTED",$Job_id,"[bipbip] Ping_checker suspects  nodes for the job $Job_id : @bad",\@bad);
    oar_Tools::notify_tcp_socket($Remote_host,$Remote_port,"ChState");
    iolib::unlock_table($base);
    iolib::disconnect($base);
    exit(2);
}else{
    oar_debug("[bipbip $Job_id] No bad node\n");
}
# end CHECK

###################################
# PROLOGUE EXECUTED ON OAR SERVER #
###################################
#
# Script is executing with job id in arguments
if (defined($Server_prologue)){
    if (-x $Server_prologue){
        my $cmd = "$Server_prologue $Job_id";
        my $pid;
        my $exit_value;
        my $signal_num;
        my $dumped_core;
        my $timeout = oar_Tools::get_default_server_prologue_epilogue_timeout();
        if (is_conf("PROLOGUE_EPILOGUE_TIMEOUT")){
            $timeout = get_conf("SERVER_PROLOGUE_EPILOGUE_TIMEOUT"); 
        }
        eval{
            undef($base);
            $SIG{ALRM} = sub { die "alarm\n" };
            alarm($timeout);
            $pid = fork();
            if ($pid == 0){
                exec($cmd);
            }
            my $wait_res = 0;
            # Avaoid to be disrupted by a signal
            while ($wait_res != $pid){
                $wait_res = waitpid($pid,0);
            }
            alarm(0);
            $exit_value  = $? >> 8;
            $signal_num  = $? & 127;
            $dumped_core = $? & 128;
        };
        if ($@){
            if ($@ eq "alarm\n"){
                if (defined($pid)){
                    my ($children,$cmd_name) = oar_Tools::get_one_process_children($pid);
                    kill(9,@{$children});
                }
                my $str = "[bipbip $Jid] Server prologue timeouted (cmd : $cmd)";
                oar_error("$str\n");
                iolib::add_new_event($base,"SERVER_PROLOGUE_TIMEOUT",$Jid,"$str");
                oar_Tools::notify_tcp_socket($Remote_host,$Remote_port,"ChState");
            }
        }elsif ($exit_value != 0){
            my $str = "[bipbip $Jid] Server prologue exit code $exit_value (!=0) (cmd : $cmd)";
            oar_error("$str\n");
            iolib::add_new_event($base,"SERVER_PROLOGUE_EXIT_CODE_ERROR",$Jid,"$str");
            oar_Tools::notify_tcp_socket($Remote_host,$Remote_port,"ChState");
        }
    }else{
        my $str = "[bipbip $Jid] Try to execute $Server_prologue but I cannot find it or it is not executable";
        oar_warn("$str\n");
        iolib::add_new_event($base,"SERVER_PROLOGUE_ERROR",$Jid,$str);
        oar_Tools::notify_tcp_socket($Remote_host,$Remote_port,"ChState");
    }
}
###############################################################################

#CALL OAREXEC ON THE FIRST NODE
my $moldable = iolib::get_current_moldable_job($base,$job->{assigned_moldable_job});
my $types = iolib::get_current_job_types($base,$Job_id);
my @resources = iolib::get_current_assigned_job_resources($base,$job->{assigned_moldable_job});
my $pro_epi_timeout = oar_Tools::get_default_prologue_epilogue_timeout();
if (is_conf("PROLOGUE_EPILOGUE_TIMEOUT")){
   $pro_epi_timeout = get_conf("PROLOGUE_EPILOGUE_TIMEOUT"); 
}
my $prologue_exec_file;
if (is_conf("PROLOGUE_EXEC_FILE")){
   $prologue_exec_file = get_conf("PROLOGUE_EXEC_FILE"); 
}
my $epilogue_exec_file;
if (is_conf("EPILOGUE_EXEC_FILE")){
   $epilogue_exec_file = get_conf("EPILOGUE_EXEC_FILE"); 
}

my @oarexec_files = ("$ENV{OARDIR}/oar_Tools.pm","$ENV{OARDIR}/oarexec");

oar_debug("[bipbip $Job_id] execute oarexec on node $host_to_connect_via_ssh\n");
my %data_to_transfer = (
        job_id              => $Job_id,
        stdout_file         => $job->{stdout_file},
        stderr_file         => $job->{stderr_file},
        launching_directory => $job->{launching_directory},
        resources           => \@resources,
        user                => $job->{job_user},
        types               => $types,
        name                => $job->{job_name},
        reservation         => $job->{reservation},
        walltime            => iolib::sql_to_duration($moldable->{moldable_walltime}),
        command             => $job->{command},
        challenge           => $job_challenge,
        almighty_hostname   => $Almighty_hostname,
        almighty_port       => $Remote_port,
        checkpoint_signal   => $job->{checkpoint_signal},
        debug_mode          => $Debug_mode,
        mode                => $job->{job_type},
        pro_epi_timeout	    => $pro_epi_timeout,
        prologue            => $prologue_exec_file,
        epilogue            => $epilogue_exec_file,
        detach_oarexec      => $Detach_oarexec
    );

# suitable Data::Dumper configuration for serialization
$Data::Dumper::Purity = 1;
$Data::Dumper::Terse = 1;
$Data::Dumper::Indent = 0;
$Data::Dumper::Deepcopy = 1;

my $error = 40;
eval {
    $SIG{ALRM} = sub { die "alarm\n" };
    alarm($pro_epi_timeout + oar_Tools::get_bipbip_ssh_hashtable_send_timeout() + oar_Tools::get_ssh_timeout());
    #open(OAREXEC, "| ssh -x $host_to_connect_via_ssh oarexec $Job_id");
    my $pid = open2(\*READ, \*WRITE, "ssh -x -T $host_to_connect_via_ssh perl - $Job_id");
    foreach my $f (@oarexec_files){
        open(FILE, $f) or die("Cannot open $f\n");
        while(<FILE>){
            print(WRITE);
        }
        close(FILE);
    }
    # End of oarexec script transfer
    #print(WRITE "\n\cd\n");
    print(WRITE "\n__END__\n");

    # Send data structure for oarexec
    print(WRITE Dumper(\%data_to_transfer)."\n");

    close(WRITE);

    my $init_done = 0;
    while(<READ>){
        oar_debug("[bipbip $Job_id] $_");
        if (($init_done == 0) and ($_ eq oar_Tools::get_bipbip_oarexec_rendez_vous())){
            $init_done = 1;
            if ($Detach_oarexec == 0){
                alarm(0);
            }
            iolib::set_job_state($base,$Job_id,"Running");
            my ($addr,$port) = split(/:/,$job->{info_type});
            oar_Judas::notify_user($base,$job->{notify},$addr,$job->{job_user},$job->{job_id},$job->{job_name},"START","Job is launched and all resources are initialised correctly.");
            # Notify interactive oarsub
            if (($job->{job_type} eq "INTERACTIVE") and ($job->{reservation} eq "None")){
                oar_debug("[bipbip $Job_id] Interactive request ;Answer to the client Qsub -I\n");
                if (defined(oar_Tools::notify_tcp_socket($addr,$port,"GOOD JOB"))){
                    oar_warn("[bipbip $Job_id] Frag job $Job_id because I cannot notify oarsub\n");
                    iolib::lock_table($base,["frag_jobs","event_logs","jobs"]);
                    iolib::frag_job($base,$Job_id);
                    iolib::unlock_table($base);
                    oar_Tools::notify_tcp_socket($Remote_host,$Remote_port,"Qdel");
                }
            }
            iolib::disconnect($base) if ($Detach_oarexec == 0);
        }
    }
    close(READ);

    waitpid($pid, 0);
    $error = $? >> 8;
    alarm(0);
};
#print("$@\n");
if (($Detach_oarexec == 1) and ($error == 0)){
    oar_debug("[bipbip $Job_id] Exit from bipbip normally\n");
    exit(0);
}else{
    $base = iolib::connect() if ($Detach_oarexec == 0);
    iolib::check_end_of_job($base,$Job_id,$error,\@hosts,$Remote_host,$Remote_port,$job->{job_user},$job->{launching_directory},$Server_epilogue);
}

iolib::disconnect($base);

exit(0);

