#!/usr/bin/perl

use oar_iolib;
use Sys::Hostname;
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use oar_Judas qw(oar_debug oar_warn oar_error);
use ping_checker qw(test_hosts);
use POSIX qw(:signal_h :sys_wait_h);
use oar_Tools;

#essential : you become oar instead of the user
#UID=EUID
$< = $>;

my $Jid= shift;
my $OarExecReattachExitValue = shift;
my $Oarexec_challenge = shift;

#overwrite env variables because we execute this script suid
$ENV{PATH}="/bin:/usr/bin:/usr/local/bin";
$ENV{USER}="oar";
$ENV{USERNAME}="oar";
$ENV{LOGNAME}="oar";

#hang signals
my $sigset   = POSIX::SigSet->new;
my $blockset = POSIX::SigSet->new(SIGINT, SIGQUIT, SIGUSR1);
sigprocmask(SIG_BLOCK, $blockset, $sigset);

#get server conf
init_conf("oar.conf");
my $remote_host = get_conf("SERVER_HOSTNAME");
my $remote_port = get_conf("SERVER_PORT");

my $deploy_hostname = get_conf("DEPLOY_HOSTNAME");
if (!defined($deploy_hostname)){
    $deploy_hostname = $remote_host;
}

my $detach_job = get_conf("DETACH_JOB");
if (!defined($detach_job)){
    $detach_job = 1;
}

#Launch the oarexec command
# arg1 --> command
# arg2 --> host
# arg3 --> enable or not pseudo tty option for ssh
sub launch($$$){
    my $usercmd=shift;
    my $host=shift;
    my $tty=shift;

    my $opt="";

    if($tty==1){
        $opt="-t";
    }
    my $cmd = "ssh -x $opt ".$host." $usercmd ";

    oar_debug("[bipbip $Jid] Launch command : $cmd\n");
    
    system($cmd);
    
    my $exit_value  = $? >> 8;
    oar_debug("[bipbip $Jid] oarexec return code = $exit_value\n");

    return($exit_value);
}

my $base;
my @hosts;

$base = iolib::connect();

my $job = iolib::get_job($base,$Jid);
my $job_challenge = iolib::get_job_challenge($base,$Jid);

@hosts = iolib::get_job_current_hostnames($base,$Jid);

if($#hosts < 0){
    oar_error("[bipbip $Jid] A Job is requested on NO HOSTS. This job must be already killed (exterminated) and come back from hell ???\n");
    exit 1;
}

my $hostToConnectViaSSH = $hosts[0];
#deploy part
if ($job->{deploy_feature} eq "YES"){
    $hostToConnectViaSSH = $deploy_hostname;
}
#deploy part

#check if we must reconnect an oarexec?
if (defined($OarExecReattachExitValue)){
    iolib::disconnect($base);
    if ($OarExecReattachExitValue =~ m/\d+/m){
        if ($Oarexec_challenge eq $job_challenge){
            checkEndOfJob($OarExecReattachExitValue);
            exit(0);
        }else{
            oar_error("[bipbip $Jid] Bad challenge from oarexec, perhaps a pirate attack??? ($Oarexec_challenge).\n");
            exit(2);
        }
    }else{
        oar_error("[bipbip $Jid] Bad argument for bipbip : $OarExecReattachExitValue\n");
        exit(2);
    }
}

#record bipbip pid and host in data base (I'm bipbip :-) )
my $hostname = hostname;
my $hostpid="$hostname:$$";
iolib::set_job_bpid($base,$Jid,$hostpid);

oar_debug("[bipbip $Jid] JOB: $Jid; User: $job->{job_user}; Command: $job->{command} ==> hosts :[@hosts]\n");

###################################
# PROLOGUE EXECUTED ON OAR SERVER #
###################################
#
# Script is executing with arguments : 
#     - job id
#     - user
#     - queue name
#     - list of job types



# check nodes
oar_debug("[bipbip $Jid] Check nodes\n");
my @bad = test_hosts(@hosts);
if ($#bad >= 0){
    iolib::lock_table($base,["jobs","job_state_logs","resources","assigned_resources","frag_jobs","resource_state_log"]);
    iolib::remove_current_assigned_resources($base,$job->{assigned_moldable_job});
    iolib::set_job_state($base,$Jid,"Error");
    iolib::set_job_message($base,$Jid,"Blacklist job nodes");
    iolib::unlock_table($base);
    oar_error("[bipbip $Jid] /!\\ Sorry but some nodes are inaccessible\n");
    iolib::add_new_event_with_host($base,"PING_CHECKER_NODE_SUSPECTED",$Jid,"[bipbip] Ping_checker suspects  nodes for the job $Jid : @bad",\@bad);
    oar_Tools::notifyTCPSocket($remote_host,$remote_port,"ChState");
    exit(2);
}else{
    oar_debug("[bipbip $Jid] No bad nodes\n");
}

# end of verif

iolib::set_job_state($base,$Jid,"Running");

#CALL OAREXEC ON THE FIRST NODE
if($job->{command} eq ""){
    iolib::disconnect($base);
    oar_debug("[bipbip $Jid] execute an interactive command\n");
    my $error = launch("oarexec $Jid $user $launchingDirectory $weight 0 @hosts ",$hostToConnectViaSSH,1);
    checkEndOfJob($error);
}else{
    if ($detach_job == 1){
        oar_debug("[bipbip $Jid] execute a NON interactive command and detach the oarexec\n");
        my $error = launch(" \' oarexec $Jid $user $launchingDirectory $weight 1 @hosts -- $usercmd  \'",$hostToConnectViaSSH,0);
    
        iolib::set_job_bpid($base,$Jid,"");
        iolib::disconnect($base);
    
        if ($error == 0){
            oar_debug("[bipbip $Jid] Exit from bipbip normaly\n");
            exit(0);
        }else{
            oar_debug("[bipbip $Jid] Oarexec returned an early error --> check end of job\n");
            checkEndOfJob($error);
        }
    }else{
        iolib::disconnect($base);
        oar_debug("[bipbip $Jid] execute a NON interactive command WITHOUT detaching oarexec\n");
        my $error = launch(" \' oarexec $Jid $user $launchingDirectory $weight 0 @hosts -- $usercmd \'",$hostToConnectViaSSH,0);
        checkEndOfJob($error);
    }
}


sub checkEndOfJob($){
    my $error = shift;

    my $base = iolib::connect();

    iolib::lock_table($base,["jobs","job_state_logs","resources","assigned_moldable_job","resource_state_logs","event_logs"]);
    my $refJob = iolib::get_job($base,$Jid);
    if ($refJob->{'state'} eq "Running"){
        oar_debug("[bipbip $Jid] Job $Jid is ended\n");
        iolib::set_finish_date($base,$Jid);
        oar_debug("[bipbip $Jid] Release nodes \n");
        iolib::remove_current_assigned_resources($base,$refJob->{assigned_moldable_job});
        if($error == 0){
            oar_debug("[bipbip $Jid] User Launch completed OK\n");
            iolib::set_job_state($base,$Jid,"Terminated");
            iolib::set_job_message($base,$Jid,"ALL is GOOD");
        }elsif ($error == 1){
            #Prologue error
            my $strWARN = "[bipbip $Jid] error of oarexec prologue; the job $Jid is in Error and the node $hosts[0] is Suspected";
            oar_warn("$strWARN\n");
            iolib::add_new_event($base,"PROLOGUE_ERROR",$Jid,"$strWARN");
            iolib::set_job_state($base,$Jid,"Error");
            iolib::set_job_message($base,$Jid,"$strWARN");
            oar_Tools::notifyTCPSocket($remote_host,$remote_port,"ChState");
        }elsif ($error == 2){
            #Epilogue error
            my $strWARN = "[bipbip $Jid] error of oarexec epilogue; the node $hosts[0] is Suspected; (jobId = $Jid)";
            oar_warn("$strWARN\n");
            iolib::add_new_event($base,"EPILOGUE_ERROR",$Jid,"$strWARN");
            iolib::set_job_state($base,$Jid,"Terminated");
            oar_Tools::notifyTCPSocket($remote_host,$remote_port,"ChState");
        }elsif ($error == 3){
            #Oarexec is killed by Leon normaly
            my $strWARN = "[bipbip $Jid] oarexec of the job $Jid was killed by Leon";
            oar_debug("$strWARN\n");
            iolib::set_job_state($base,$Jid,"Error");
            iolib::set_job_message($base,$Jid,"$strWARN");
        }elsif ($error == 4){
            #Oarexec was killed by Leon and epilogue of oarexec is in error
            my $strWARN = "[bipbip $Jid] The job $Jid was killing by Leon and oarexec epilogue was in error";
            oar_warn("$strWARN\n");
            iolib::add_new_event($base,"EPILOGUE_ERROR",$Jid,"$strWARN");
            iolib::set_job_state($base,$Jid,"Error");
            iolib::set_job_message($base,$Jid,"$strWARN");
            oar_Tools::notifyTCPSocket($remote_host,$remote_port,"ChState");
        }elsif ($error == 5){
            #Oarexec is not able write in the node file
            my $strWARN = "[bipbip $Jid] oarexec can t create the node file";
            oar_warn("$strWARN\n");
            iolib::add_new_event($base,"CAN_NOT_WRITE_NODE_FILE",$Jid,"$strWARN");
            iolib::set_job_state($base,$Jid,"Error");
            iolib::set_job_message($base,$Jid,"$strWARN");
            oar_Tools::notifyTCPSocket($remote_host,$remote_port,"ChState");
        }elsif ($error == 6){
            #Oarexec can not write its pid file
            my $strWARN = "[bipbip $Jid] oarexec cannot write its pid file";
            oar_warn("$strWARN\n");
            iolib::add_new_event($base,"CAN_NOT_WRITE_PID_FILE",$Jid,"$strWARN");
            iolib::set_job_state($base,$Jid,"Error");
            iolib::set_job_message($base,$Jid,"$strWARN");
            oar_Tools::notifyTCPSocket($remote_host,$remote_port,"ChState");
        }elsif ($error == 7){
            #Can t get shell of user
            my $strWARN = "[bipbip $Jid] Can't get shell of user $user, so I suspect node $hosts[0]";
            oar_warn("$strWARN\n");
            iolib::add_new_event($base,"USER_SHELL",$Jid,"$strWARN");
            iolib::set_job_state($base,$Jid,"Error");
            iolib::set_job_message($base,$Jid,"$strWARN");
            oar_Tools::notifyTCPSocket($remote_host,$remote_port,"ChState");
        }elsif ($error == 10){
            #oarexecuser.sh can not go into working directory
            my $strWARN = "[bipbip $Jid] Can't go into the working directory $launchingDirectory of the job on node $hosts[0]";
            oar_warn("$strWARN\n");
            iolib::add_new_event($base,"WORKING_DIRECTORY",$Jid,"$strWARN");
            iolib::set_job_state($base,$Jid,"Error");
            iolib::set_job_message($base,$Jid,"$strWARN");
        }elsif ($error == 20){
            #oarexecuser.sh can not write stdout and stderr files
            my $strWARN = "[bipbip $Jid] Can't create .stdout and .stderr files in $launchingDirectory on the node $hosts[0]";
            oar_warn("$strWARN\n");
            iolib::add_new_event($base,"OUTPUT_FILES",$Jid,"$strWARN");
            iolib::set_job_state($base,$Jid,"Error");
            iolib::set_job_message($base,$Jid,"$strWARN");
        }elsif ($error == 12){
            #oarexecuser.sh can not go into working directory and epilogue is in error
            my $strWARN = "[bipbip $Jid] Can't go into the working directory $launchingDirectory of the job on node $hosts[0] AND epilogue is in error";
            oar_warn("$strWARN\n");
            iolib::add_new_event($base,"WORKING_DIRECTORY",$Jid,"$strWARN");
            iolib::add_new_event($base,"EPILOGUE_ERROR",$Jid,"$strWARN");
            iolib::set_job_state($base,$Jid,"Error");
            iolib::set_job_message($base,$Jid,"$strWARN");
            oar_Tools::notifyTCPSocket($remote_host,$remote_port,"ChState");
        }elsif ($error == 22){
            #oarexecuser.sh can not write stdout and stderr files and epilogue is in error
            my $strWARN = "[bipbip $Jid] Can't get shell of user $user, so I suspect node $hosts[0] AND epilogue is in error";
            oar_warn("$strWARN\n");
            iolib::add_new_event($base,"OUTPUT_FILES",$Jid,"$strWARN");
            iolib::add_new_event($base,"EPILOGUE_ERROR",$Jid,"$strWARN");
            iolib::set_job_state($base,$Jid,"Error");
            iolib::set_job_message($base,$Jid,"$strWARN");
            oar_Tools::notifyTCPSocket($remote_host,$remote_port,"ChState");
        }else{
            my $strWARN = "[bipbip $Jid] error of oarexec, exit value = $error; the job $Jid is in Error and the node $hosts[0] is Suspected";
            oar_warn("$strWARN\n");
            iolib::add_new_event($base,"EXIT_VALUE_OAREXEC",$Jid,"$strWARN");
            iolib::set_job_state($base,$Jid,"Error");
            iolib::set_job_message($base,$Jid,"$strWARN");
            oar_Tools::notifyTCPSocket($remote_host,$remote_port,"ChState");
        }
    }else{
        oar_debug("[bipbip $Jid] I was previously killed or Terminated but I did not know that!!\n");
    }
    iolib::unlock_table($base);
    iolib::disconnect($base);


    oar_Tools::notifyTCPSocket($remote_host,$remote_port,"BipBip");
}

exit(0);

