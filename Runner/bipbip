#!/usr/bin/perl

use oar_iolib;
use Sys::Hostname;
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use oar_Judas qw(oar_debug oar_warn oar_error);
use ping_checker;
use oar_Tools;
use Data::Dumper;
use IPC::Open2;

my $Job_id= shift;
my $Oarexec_reattach_exit_value = shift;
my $Oarexec_challenge = shift;

#get server conf
init_conf("oar.conf");
my $Remote_host = get_conf("SERVER_HOSTNAME");
my $Remote_port = get_conf("SERVER_PORT");

my $Almighty_hostname = $Remote_host;
if (($Almighty_hostname =~ /^\s*localhost.*$/) or ($Almighty_hostname =~ /^\s*127.*$/)){
    $Almighty_hostname = hostname();
}

my $Deploy_hostname = get_conf("DEPLOY_HOSTNAME");
if (!defined($Deploy_hostname)){
    $Deploy_hostname = $Remote_host;
}
my $Debug_mode = get_conf("OAREXEC_DEBUG_MODE");
if (!defined($Debug_mode)){
    $Debug_mode = 0;
}

my $base;

$base = iolib::connect();

my $job = iolib::get_job($base,$Job_id);
my $job_challenge = iolib::get_job_challenge($base,$Job_id);

my @hosts = iolib::get_job_current_hostnames($base,$Job_id);

if($#hosts < 0){
    oar_error("[bipbip $Job_id] A Job is requested on NO HOSTS. This job must be already killed (exterminated) and come back from hell ???\n");
    iolib::add_new_event($base, "BIPBIP_BAD_JOBID", $Job_id, "A Job is requested on NO HOSTS. This job must be already killed (exterminated) and come back from hell ???");
    iolib::disconnect($base);
    exit 1;
}

my $host_to_connect_via_ssh = $hosts[0];
#deploy part
my $types = iolib::get_current_job_types($base,$Job_id);
if (defined($types->{deploy})){
    $host_to_connect_via_ssh = $Deploy_hostname;
}
#deploy part

#check if we must treate the end of a oarexec
if (defined($Oarexec_reattach_exit_value)){
    if ($Oarexec_reattach_exit_value =~ m/\d+/m){
        if ($Oarexec_challenge eq $job_challenge){
            iolib::check_end_of_job($base, $Job_id, $Oarexec_reattach_exit_value, \@hosts, $Remote_host, $Remote_port,$job->{job_user},$job->{launching_directory});
            iolib::disconnect($base);
            exit(0);
        }else{
            oar_error("[bipbip $Job_id] Bad challenge from oarexec, perhaps a pirate attack??? ($Oarexec_challenge).\n");
            iolib::add_new_event($base, "BIPBIP_CHALLENGE", $Job_id, "Bad challenge from oarexec, perhaps a pirate attack??? ($Oarexec_challenge)");
            iolib::disconnect($base);
            exit(2);
        }
    }else{
        oar_error("[bipbip $Job_id] Bad argument for bipbip : $Oarexec_reattach_exit_value\n");
        iolib::disconnect($base);
        exit(2);
    }
}

# ELSE we must launch oarexec on the first node
oar_debug("[bipbip $Job_id] JOB: $Job_id; User: $job->{job_user}; Command: $job->{command} ==> hosts :[@hosts]\n");

###################################
# PROLOGUE EXECUTED ON OAR SERVER #
###################################
#
# Script is executing with arguments : 
#     - job id
#     - user
#     - queue name
#     - list of job types



# CHECK nodes
oar_debug("[bipbip $Job_id] Check nodes : @hosts\n");
my @bad = ping_checker::test_hosts(@hosts);
if ($#bad >= 0){
    iolib::lock_table($base,["jobs","job_state_logs","resources","assigned_resources","frag_jobs","resource_state_logs","challenges","moldable_job_descriptions","job_types","job_dependencies","job_resource_groups","job_resource_descriptions"]);
    iolib::set_job_state($base,$Job_id,"Error");
    iolib::set_job_message($base,$Job_id,"Several nodes are not responding");
    iolib::unlock_table($base);
    oar_error("[bipbip $Job_id] /!\\ Sorry but some nodes are inaccessiblei : @bad\n");
    iolib::add_new_event_with_host($base,"PING_CHECKER_NODE_SUSPECTED",$Job_id,"[bipbip] Ping_checker suspects  nodes for the job $Job_id : @bad",\@bad);
    oar_Tools::notify_tcp_socket($Remote_host,$Remote_port,"ChState");
    my ($addr,$port) = split(/:/,$job->{info_type});
    oar_Tools::notify_tcp_socket($addr,$port,"INVALID RESOURCES");
    iolib::disconnect($base);
    exit(2);
}else{
    oar_debug("[bipbip $Job_id] No bad node\n");
}
# end CHECK


#CALL OAREXEC ON THE FIRST NODE
my $moldable = iolib::get_current_moldable_job($base,$job->{assigned_moldable_job});
my $types = iolib::get_current_job_types($base,$Job_id);
my @resources = iolib::get_current_assigned_job_resources($base,$job->{assigned_moldable_job});
my $pro_epi_timeout = oar_Tools::get_default_prologue_epilogue_timeout();
if (is_conf("PROLOGUE_EPILOGUE_TIMEOUT")){
   $pro_epi_timeout = get_conf("PROLOGUE_EPILOGUE_TIMEOUT"); 
}
my $prologue_exec_file;
if (is_conf("PROLOGUE_EXEC_FILE")){
   $prologue_exec_file = get_conf("PROLOGUE_EXEC_FILE"); 
}
my $epilogue_exec_file;
if (is_conf("EPILOGUE_EXEC_FILE")){
   $epilogue_exec_file = get_conf("EPILOGUE_EXEC_FILE"); 
}

my @oarexec_files = ("$ENV{OARDIR}/oar_Tools.pm","$ENV{OARDIR}/oarexec");

oar_debug("[bipbip $Job_id] execute oarexec on node $host_to_connect_via_ssh\n");
my %data_to_transfer = (
        job_id              => $Job_id,
        stdout_file         => $job->{stdout_file},
        stderr_file         => $job->{stderr_file},
        launching_directory => $job->{launching_directory},
        resources           => \@resources,
        user                => $job->{job_user},
        types               => $types,
        name                => $job->{job_name},
        reservation         => $job->{reservation},
        walltime            => iolib::sql_to_duration($moldable->{moldable_walltime}),
        command             => $job->{command},
        challenge           => $job_challenge,
        almighty_hostname   => $Almighty_hostname,
        almighty_port       => $Remote_port,
        checkpoint_signal   => $job->{checkpoint_signal},
        debug_mode          => $Debug_mode,
        mode                => $job->{job_type},
        pro_epi_timeout	    => $pro_epi_timeout,
        prologue            => $prologue_exec_file,
        epilogue            => $epilogue_exec_file
    );

# suitable Data::Dumper configuration for serialization
$Data::Dumper::Purity = 1;
$Data::Dumper::Terse = 1;
$Data::Dumper::Indent = 0;
$Data::Dumper::Deepcopy = 1;

my $error = 40;
eval {
    $SIG{ALRM} = sub { die "alarm\n" };
    alarm(oar_Tools::get_default_prologue_epilogue_timeout() + oar_Tools::get_bipbip_ssh_hashtable_send_timeout() + oar_Tools::get_ssh_timeout());
    #open(OAREXEC, "| ssh -x $host_to_connect_via_ssh oarexec $Job_id");
    my $pid = open2(\*READ, \*WRITE, "ssh -x $host_to_connect_via_ssh perl - $Job_id");
    foreach my $f (@oarexec_files){
        open(FILE, $f) or die("Cannot open $f\n");
        while(<FILE>){
            print(WRITE);
        }
        close(FILE);
    }
    # End of oarexec script transfer
    print(WRITE "\n\cd\n");

    # Send data structure for oarexec
    print(WRITE Dumper(\%data_to_transfer)."\n");

    close(WRITE);

    while(<READ>){
        oar_debug("[bipbip $Job_id] $_");
    }
    close(READ);

    waitpid($pid, 0);
    $error = $? >> 8;
    alarm(0);
};
#print("$@\n");
if ($error == 0){
    iolib::set_job_state($base,$Job_id,"Running");
    my ($addr,$port) = split(/:/,$job->{info_type});
    oar_Judas::notify_user($base,$job->{notify},$addr,$job->{job_user},$job->{job_id},$job->{job_name},"START","Job is launched and all resources are initialised correctly.");
    # Notify interactive oarsub
    if ($job->{job_type} eq "INTERACTIVE"){
        oar_debug("[bipbip $Job_id] Interactive request ;Answer to the client Qsub -I\n");
        if (defined(oar_Tools::notify_tcp_socket($addr,$port,"GOOD JOB"))){
            oar_warn("[bipbip $Job_id] Frag job $Job_id because I cannot notify oarsub\n");
            iolib::lock_table($base,["frag_jobs","event_logs","jobs"]);
            iolib::frag_job($base,$Job_id);
            iolib::unlock_table($base);
        }
    }
    oar_debug("[bipbip $Job_id] Exit from bipbip normally\n");
}else{
    oar_debug("[bipbip $Job_id] Oarexec returned an early error ($error) --> check end of job\n");
    iolib::check_end_of_job($base,$Job_id,$error,\@hosts,$Remote_host,$Remote_port,$job->{job_user},$job->{launching_directory});
}

iolib::disconnect($base);

exit(0);

