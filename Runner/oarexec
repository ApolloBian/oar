#!/usr/bin/perl
#script executed on the first reserved node
# Exit codes are:
#     - 0 : everything worked normally
#     - 1 : prologue error (exit value not equal to 0 or timeout exceeded)
#     - 2 : epilogue error (exit value not equal to 0 or timeout exceeded)
#     - 3 : this script was killed by Leon normally
#     - 4 : this script was killed by Leon normally and epilogue was in error (like for 2)
#     - 5 : this script was not able to create the node file
#     - 6 : this script was not able to create the pid file
#     - 7 : cannot get the shell value for the user
#     - 8 : this script was not able to create tmp directory
#     - 12 : cannot go into the launching directory of the job and epilogue was in error
#     - 10 : cannot go into the launching directory of the job
#     - 20 : cannot create STDOUT and STDERR files
#     - 22 : cannot go into the launching directory of the job and epilogue was in error
#     - 30 : timeout of the bipbip hashtable send
#     - 31 : bad hashtable sent by bipbip
#     - 33 : oarexec was stopped normally via USR1 signal but there were an epilogue error
#     - 34 : all worked normally and this is the result of an USR1 signal
#
# The exit code is sent to the Almighty via its TCP socket
#
# oarexec read a hashtable from bipbip, execute the prologue and then close STD file descriptor + fork a child and kill itself.
# So the SSH return just after job initialisation and prologue

use strict;
use oar_conflib qw(init_conf dump_conf get_conf is_conf);
use oar_Tools;
use Sys::Hostname;
use oar_Judas qw(oar_debug oar_warn oar_error);
use POSIX qw(:signal_h :errno_h :sys_wait_h);
use oar_Tools;

my $Job_id = shift;

$| = 1;
# block signals until we define the handlers
my $sigset   = POSIX::SigSet->new;
my $Blockset = POSIX::SigSet->new(SIGINT, SIGTERM, SIGQUIT, SIGCHLD, SIGUSR2, SIGUSR1);
sigprocmask(SIG_BLOCK, $Blockset, $sigset);

init_conf("oar.conf");
my $Bin_Path = $ENV{OARDIR}."/";
my $Prologue = $ENV{HOME}."/oar_prologue";
my $Epilogue = $ENV{HOME}."/oar_epilogue";
my $Tmp_file_prefix = oar_Tools::get_default_oarexec_directory();

my $Timeout = 60;
if (is_conf("PROLOGUE_EPILOGUE_TIMEOUT")){
   $Timeout = get_conf("PROLOGUE_EPILOGUE_TIMEOUT"); 
}

my $Debug_mode;
my $Node_file;
my $Pid_file;
my $Kill_myself = 0;
my $Oarexec_exit_code = 0;

#Notify Almighty.
#arg1 --> exit value
sub quit_oarexec($$){
    my $exit_value = shift;
    my $job_data = shift;
    
    my $max_wait_time = 300;
    my $wait_time = 30;
    
    while (1){
        if (!defined(oar_Tools::notify_tcp_socket($job_data->{almighty_hostname},$job_data->{almighty_port},"OAREXEC_$Job_id"."_$exit_value"."_$job_data->{challenge}"))){
            oar_debug("[oarexec $Job_id] I notified Almighty with my exit value $exit_value;so I am exiting\n");
            exit($exit_value);
        }else{
            oar_error("[oarexec $Job_id] I cannot notify Almighty; maybe the server is down or network is wrong configured\n");
        }
        sleep($wait_time);
        if ($wait_time < $max_wait_time){
            $wait_time = 2 * $wait_time;
            if ($wait_time > $max_wait_time){
                $wait_time = $max_wait_time;
            }
        }
    }
    exit($exit_value);
}


#delete temporary file
sub clean_all(){
    #system("rm -f $OAR_FILE_NODES $oarPidFile");
    unlink($Node_file,$Pid_file);
}

# read a line on a socket
# arg1 --> socket
# arg2 --> timeout
# return 0 if the read times out
sub read_socket_line($$){
    my $sock = shift;
    my $timeout = shift;

    my $char = "a";
    my $res = 1;
    my $rin = '';
    my $line;
    vec($rin,fileno($sock),1) = 1;
    my $rin_tmp;
    while (($res > 0) && ($char ne "\n") && ($char ne "")){
        $res = select($rin_tmp = $rin, undef, undef, $timeout);
        if ($res > 0){
            sysread($sock,$char,1);
            if ($char ne "\n"){
                $line .= $char;
            }
        }
    }
    return($res,$line);
}

#kill all child of the pid
# arg1 --> child pid
sub kill_childs($){
    my $child_pid = shift;

    my @childs = oar_Tools::getOneProcessChilds($child_pid);
    system("sudo /bin/kill -9 @childs 2>&1 > /dev/null");
}

sub send_kill_signal_to_myself(){
    my $father = $$;
    my $pid=fork;
    if($pid==0){
        sleep(5);
        kill('SIGUSR2', $father);
        exit();
    }
}

# Retrieve job oinformations from bipbip
my $bipbip_line;
eval {
    $SIG{ALRM} = sub { die "alarm\n" };
    alarm($Timeout);
    $bipbip_line = <STDIN>;
    alarm(0);
};
if( $@ ){
    oar_error("[oarexec $Job_id] Timeout of hashtable SSH transfer\n");
    exit(30);
}
my $Job = eval( <STDIN> );
if (!defined($Job->{job_id})){
    oar_error("[oarexec $Job_id] Bad SSH ashtable transfered\n");
    exit(31);
}

my $host = hostname();

oar_debug("[oarexec $Job_id] job id : $Job_id user : $Job->{user}; launchingDirectory : $Job->{launching_directory}\n");

if (! mkdir($Tmp_file_prefix)){
    oar_error("[oarexec $Job_id] I cannot create directory $Tmp_file_prefix\n");
    exit(8);
}

#create node set file and parse command args
$Node_file = "$Tmp_file_prefix/OAR_$Job_id";
if (! open(FILE,">$Node_file")){
    oar_error("[oarexec $Job_id] I cannot write file $Node_file\n");
    exit(5);
}
#Feed the node file
my %tmp_res;
foreach my $r (@{$Job->{resources}}){
    push(@tmp_res, $r->{network_address}); 
}
foreach my $f (sort(@tmp_res)){
    print(FILE "$f\n") or exit(5);
}
close FILE;

oar_debug("[oarexec $Job_id] nom de commande [$Job->{command}]\n");

# Launch prologue script
# Exit code of prologue and epilogue
my $Script_error = 0;
eval {
    $SIG{ALRM} = sub { die "alarm\n" };
    alarm($Timeout);
    oar_debug("[oarexec $Job_id] LAUNCH prologue : $Prologue $Job_id $Job->{user} $Node_file\n");
    $Script_error = system("$Prologue $Job_id $Job->{user} $Node_file");
    oar_debug("[oarexec $Job_id] END prologue : $Prologue\n");
    alarm(0);
};
if( $@ || ($Script_error != 0)){
    oar_debug("[oarexec $Job_id] Prologue error : $@; return code = $Script_error\n");
    clean_all();
    oar_error("[oarexec $Job_id] Error in the OAR prolog execution\n");
    exit(1);
}

# Get user shell
my @pass_info = getpwnam($Job->{user});
my $shell = $pass_info[8];
if (!defined($shell)){
    clean_all();
    oar_error("[oarexec $Job_id] Error : user $Job->{user} does not exist on this node, $host\n");
    exit(7);
}

my $cmd;
if ( $Job->{mode} eq "PASSIVE" ){
    oar_debug("[oarexec $Job_id] Begin a passive command\n");
    $cmd = "sudo -H -u $Job->{user} sh -c \"$Bin_Path/oarexecuser.sh $Node_file $Job_id $Job->{user} $shell $Job->{launching_directory} P $Job->{stdout_file} $Job->{stderr_file} $Job->{command}\"";
}

#resolve terminal type problems
my $terminal = $ENV{TERM};
if (($terminal ne "") and ($terminal ne "unknown")){
    $ENV{TERM} = $terminal;
}else{
    $ENV{TERM} = "xterm";
}

#oar own the tty
#so we must change owner for the user
system("sh -c 'TTY=`tty` && test -e \$TTY && sudo chown $Job->{user}:oar \$TTY && sudo chmod 660 \$TTY '");

# pipe for notify the end of a child process
pipe(pipe_child_read,pipe_child_write);
autoflush pipe_child_write 1;
autoflush pipe_child_read 1;

sub child_signal_handler {
    $SIG{CHLD} = \&child_signal_handler;
    
    my $wait_pid_ret ;
    while (($wait_pid_ret = waitpid(-1,WNOHANG)) > 0){
        my $exit_value = $? >> 8;
        print(pipe_child_write "$wait_pid_ret $exit_value\n");
    }
}
$SIG{CHLD} = \&child_signal_handler;

#For kill signal
pipe(pipe_kill_read,pipe_kill_write);
autoflush pipe_kill_write 1;
autoflush pipe_kill_read 1;

sub kill_signal_handler {
    $SIG{TERM} = \&kill_signal_handler;
    $SIG{INT} = \&kill_signal_handler;
    $SIG{QUIT} = \&kill_signal_handler;

    oar_debug("[oarexec $Job_id] In signal handler of @_\n");
    print(pipe_kill_write "KILL\n");
}

$SIG{TERM} = \&kill_signal_handler;
$SIG{INT} = \&kill_signal_handler;
$SIG{QUIT} = \&kill_signal_handler;

sub stop_signal_handler {
    $SIG{USR1} = \&stop_signal_handler;

    oar_debug("[oarexec $Job_id] In stop signal handler of @_\n");
    print(pipe_kill_write "STOP\n");
}

$SIG{USR1} = \&stop_signal_handler;

sub chekpoint_signal_handler {
    $SIG{USR2} = \&chekpoint_signal_handler;

    oar_debug("[oarexec $Job_id] In checkpoint signal handler of @_\n");
    print(pipe_kill_write "CHECKPOINT\n");
}

$SIG{USR2} = \&chekpoint_signal_handler;

#Detach process from bipbip SSH
oar_debug("[oarexec $Job_id] I am detaching the oarexec process\n");

if(fork() != 0){
    # Exit from main oarexec
    exit(0);
}
#with these 3 lines, ssh will close the connection
#    close(STDIN);
#    close(STDOUT);
#    close(STDERR);
open(STDIN, "/dev/zero");
open(STDOUT, ">/dev/null");
open(STDERR, ">/dev/null");

#Write file with this oarexec pid
my $oarexec_pid_file = "$Tmp_file_prefix/".oar_Tools::get_oar_pid_file_name($Job_id);
if ((!open(FILEPID,">$Pid_file")) or (!print(FILEPID "$$"))){
    oar_error("[oarexec $Job_id] I cannot write file $Pid_file\n");
    clean_all();
    quit_oarexec(6,$Job);
}
close(FILEPID);

sigprocmask(SIG_UNBLOCK, $Blockset);

my $pid = $$;
if ($Job->{mode} eq "PASSIVE"){
    oar_debug("[oarexec $Job_id] Launch the command : $cmd\n");
    my $pid = fork;
    if($pid == 0){
        #CHILD
        $SIG{CHLD} = 'DEFAULT';
        $SIG{TERM} = 'DEFAULT';
        $SIG{INT}  = 'DEFAULT';
        $SIG{QUIT} = 'DEFAULT';
        $SIG{USR1} = 'DEFAULT';
        $SIG{USR2} = 'DEFAULT';
        oar_debug("[oarexec $Job_id] child exec: $cmd\n");
        exec($cmd);
    }
}
oar_debug("[oarexec $Job_id] child pid = $pid\n");

my $kill_myself = 0;

my $res_read;
my $line_read;
my $rin = '';
my $rin_sig = '';
my $rin_pipe = '';
vec($rin_sig,fileno(pipe_kill_read),1) = 1;
vec($rin_pipe,fileno(pipe_child_read),1) = 1;
$rin = $rin_sig | $rin_pipe;
my $rin_tmp;
my $Stop_signal = 0;
# wait end of the child process or KILL notification
while (($line_read != $pid) and ($Stop_signal == 0)){
    oar_debug("[oarexec $Job_id] wait end of child process or kill notification\n");
    select($rin_tmp = $rin, undef, undef, undef);
    oar_debug("[oarexec $Job_id] A CHLD or kill signal arrived\n");
    ($res_read,$line_read) = read_socket_line(\*pipe_child_read,1);
    oar_debug("[oarexec $Job_id] PIPE reads : $res_read,$line_read\n");
    if ($line_read <= 0){
        ($res_read,$line_read) = read_socket_line(\*pipe_kill_read,1);
        oar_debug("[oarexec $Job_id] pipe kill signal : $res_read,$line_read\n");
        if ($line_read eq "KILL"){
            oar_debug("[oarexec $Job_id] Kill children\n");
            killChilds($pid);
            $kill_myself = 1;
        }elsif ($line_read eq "STOP"){
            oar_debug("[oarexec $Job_id] Receive STOP notification\n");
            if ($Job->{mode} eq "INTERACTIVE"){
                $Stop_signal = 1;
            }else{
                oar_warn("[oarexec $Job_id] Receive USR1 signal so someone wants to finish this job but it is not an INTERACTIVE one\n");
            }
        }elsif ($line_read eq "CHECKPOINT"){
            #We must send SIGUSR2 to the child of $pid
            my %tmp_hash = oar_Tools::get_all_process_childs();
            my $pid_to_send_kill = @{$tmp_hash{$pid}}[0];
            if (defined($pid_to_send_kill)){
                oar_debug("[oarexec $Job_id] Send signal SIGUSR2 to the pid $pid_to_send_kill\n");
                system("sudo kill -s $Job->{checkpoint_signal} $pid_to_send_kill");
            }else{
                oar_warn("[oarexec $Job_id] Cannot find pid of user process??? I will retry in 5 seconds\n");
                send_kill_signal_to_myself();
            }
        }
    }else{
        $line_read =~ m/(\d+) (\d+)/m;
        if ($1 == $pid){
            oar_debug("[oarexec $Job_id] Reset CHLD signal handler\n");
            $line_read = $pid;
            $Oarexec_exit_code = $2 * 10;
        }
    }
}

$SIG{CHLD} = 'DEFAULT';
$SIG{TERM} = 'IGNORE';
$SIG{INT}  = 'IGNORE';
$SIG{QUIT} = 'IGNORE';
$SIG{USR1} = 'DEFAULT';
$SIG{USR2} = 'DEFAULT';
close(pipe_child_write);
close(pipe_child_read);
close(pipe_kill_write);
close(pipe_kill_read);

oar_debug("[oarexec $Job_id] Job Terminated\n");
# Launch epilogue script
eval {
    $SIG{ALRM} = sub { die "alarm\n" };
    alarm($Timeout);
    oar_debug("[oarexec $Job_id] LAUNCH epilogue : $Epilogue $Job_id $Job->{user} $Node_file $Job->{command}\n");
    $Script_error = system("$Epilogue $Job_id $Job->{user} $Node_file $Job->{command}");
    oar_debug("[oarexec $Job_id] END epilogue : $Epilogue\n");
    alarm(0);
};
if( $@ || ($Script_error != 0)){
    oar_debug("[oarexec $Job_id] Epilogue error : $@; return code = $Script_error\n");
    clean_all();
    oar_error("[oarexec $Job_id] Error in the OAR epilog execution\n");
    if ($Kill_myself == 1){
        quit_oarexec(4,$Job);
    }elsif($Stop_signal == 1){
        quit_oarexec(33,$Job);
    }else{
        quit_oarexec(2+$Oarexec_exit_code,$Job);
    }
}

clean_all();
if ($kill_myself == 1){
    quit_oarexec(3,$Job);
}elsif($Stop_signal == 1){
    quit_oarexec(34,$Job);
}else{
    quit_oarexec(0+$Oarexec_exit_code,$Job);
}

