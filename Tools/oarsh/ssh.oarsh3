#!/bin/bash
# $Id$
###############################################################################
# This script is an example of wrapper that can be used to masquerade the oarsh 
# command as the ssh command for tools that do not allow to change the 
# connector using an option, an environment variable or a configuration.
# The basic usage is to make a symlink or a copy of this file named "ssh" and
# stored somewhere in your execution PATH.
# Ex: ln -s /usr/lib/oar/ssh.oarsh ~/bin/ssh
#
# Mechanism:
# First it allows to define which hosts to connect using OARSH or using the 
# real SSH. REGEX lists of hostnames can be set in the ~/.oarsh-hosts-include
# and ~/.oarsh-hosts-exclude files to specify that.
# Then, it allows to avoid OARSH confict with SSH "-l" option, which occurs for
# instance when using Mpich 1 if not built using the "-rshnol" option. 
###############################################################################

# OARSH and SSH hosts REGEXs
OARSH_HOSTS_INCLUDE_FILE=~/.oarsh-hosts-include
OARSH_HOSTS_EXCLUDE_FILE=~/.oarsh-hosts-exclude
OARSH_CMD=oarsh
SSH_CMD=/usr/bin/ssh

# unset bash glob expension 
set -f

# Parse SSH options (must be called twice, see below parse_args)
# Be carefull: watch openssh ssh.c source file for new options...
parse_opts() {
	OPTIND=
	while getopts "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:F:I:L:MNO:PR:S:TVw:XY" OPT; do
		case $OPT in
			1 | 2 | 4 | 6 | n | f | x | X | Y | g | P | a | A | k | t | v | V | q | M | s | T | N | C )
				SSHARGS_OPT[$((SSHARGS_OPTCOUNT++))]="-$OPT"
				;;
			O | i | I | w | e | c | m | p | l | L | R | D | o | S | b | F )
				SSHARGS_OPT[$((SSHARGS_OPTCOUNT++))]="-$OPT $OPTARG"
				;;
			* ) 
				SSHARGS_ERROR=255
				;;
		esac
	done
}

# Parse the SSH command args
# Syntax is `ssh [opts] [user@]<host> [opts] [command]'
parse_args() {
	unset SSHARGS_OPT
	SSHARGS_ERROR=0
	SSHARGS_OPTCOUNT=0
	parse_opts $@
	shift $((OPTIND-1))
	SSHARGS_HOST="${1/#*@/}"
	[ -n "$SSHARGS_HOST" ] || SSHARGS_ERROR=255
	SSHARGS_USER="${1/%$SSHARGS_HOST/}"
	SSHARGS_USER="${SSHARGS_USER/%@/}"
	shift 1
	parse_opts $@
	shift $((OPTIND-1))
	SSHARGS_COMMAND="$@"
}

# Debug function: dump parsed information
dump() {
	echo $SSHARGS_OPTCOUNT
	for ((i=0;i<$SSHARGS_OPTCOUNT;i++)); do
		echo "SSHARGS_OPT[$i]="${SSHARGS_OPT[$i]}
	done
	echo "SSHARGS_OPTCOUNT="$SSHARGS_OPTCOUNT
	echo "SSHARGS_HOST="$SSHARGS_HOST
	echo "SSHARGS_USER="$SSHARGS_USER
	echo "SSHARGS_COMMAND="$SSHARGS_COMMAND
	echo "SSHARGS_ERROR="$SSHARGS_ERROR
}

# Check whether SSH or OARSH must be run depending on the hostname.
# First check if host is in the include list, if yes run OARSH.
# Else check if host is in the exclude list, if yes run SSH.
# Else run OARSH.
check_host() {
	if [ -n "$SSHARGS_ERROR" -a $SSHARGS_ERROR -eq 0 -a -n "$SSHARGS_HOST" ]; then
		if [ -r $OARSH_HOSTS_INCLUDE_FILE ]; then
			for h in $(< $OARSH_HOSTS_INCLUDE_FILE); do
				if [[ $SSHARGS_HOST =~ $h ]]; then
					return 0
				fi
			done
		fi
		if [ -r $OARSH_HOSTS_EXCLUDE_FILE ]; then
			for h in $(< $OARSH_HOSTS_EXCLUDE_FILE); do
				if [[ $SSHARGS_HOST =~ $h ]]; then
					return 1
				fi
			done
		fi
		return 0
	fi
	return 1
}

# Remove the -l ssh option for calls of OARSH.
fix_opts() {
	OPTS=
	for ((i=0;i<$SSHARGS_OPTCOUNT;i++)); do
		[[ ${SSHARGS_OPT[$i]} =~ "^-l" ]] || OPTS="$OPTS ${SSHARGS_OPT[$i]}"
	done
}

# Main program

# Parse args (the $@ var of the main program stays unchanged)
parse_args $@
# check if SSH or OARSH must be called depending on the host
if check_host; then
	# Remove the -l option
	fix_opts
	# Run OARSH with neither the -l option nor any username@ 
	exec $OARSH_CMD $OPTS $SSHARGS_HOST "$SSHARGS_COMMAND"
else
	exec $SSH_CMD "$@"
fi
