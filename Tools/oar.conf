# Database type ("mysql" or "Pg")
DB_TYPE = mysql

# DataBase hostname
DB_HOSTNAME=localhost

# Database base name
DB_BASE_NAME=oar

# DataBase user name
DB_BASE_LOGIN=oar

# DataBase user password
DB_BASE_PASSWD=oar

# DataBase read only user name
#DB_BASE_LOGIN_RO=oar_ro

# DataBase read only user password
#DB_BASE_PASSWD_RO=oar_ro

# OAR server hostname
SERVER_HOSTNAME=localhost

# OAR server port
SERVER_PORT=6666

# when the user does not specify a -l option then oar use this
OARSUB_DEFAULT_RESOURCES = /resource_id=1

# Specify where we are connected with a job of the deploy type
DEPLOY_HOSTNAME = 127.0.0.1

# Specify where we are connected with a job of the cosystem type
COSYSTEM_HOSTNAME = 127.0.0.1

# If you want to free a process per job on the server you can change this tag
#into 1 (you must enable all nodes to connect to SERVER_PORT on the SERVER_HOSTNAME)
DETACH_JOB_FROM_SERVER = 0

# OAR sentinelle
# sentinelle may be used instead of ping to check aliveness of nodes.
# uncomment next line to use sentinelle. Give the complete command path.
#SENTINELLE_COMMAND=/usr/bin/sentinelle -cconnect=ssh,timeout=3000
# If you use sentinelle.pl then you must use this tag.
#SENTINELLE_SCRIPT_COMMAND=/var/lib/oar/sentinelle.pl -t 5 -w 20

# OAR fping
# fping may be used instead of ping to check aliveness of nodes.
# uncomment next line to use fping. Give the complete command path.
#FPING_COMMAND=/usr/bin/fping -q 

# OAR nmap
# nmap may be used instead of ping to check aliveness of nodes.
# uncomment next line to use nmap. Give the complete command path.
# It will test to connect on the ssh port (22)
#NMAP_COMMAND=/usr/bin/nmap -p 22 -n -T5

# OAR GENERIC
# a specific script may be used instead of ping to check aliveness of nodes.
# uncomment next line and give the complete command path and its arguments.
# The script must return bad nodes on STDERR (1 line for a bad node and it must
# have exactly the same name that OAR has given in argument of the command)
#GENERIC_COMMAND=/path/to/command arg1 arg2

# OAR log level: 3(debug+warnings+errors), 2(warnings+errors), 1(errors)
LOG_LEVEL=2

# If you want to debug oarexec on nodes then affect 1 (only effective if DETACH_JOB_FROM_SERVER = 1)
OAREXEC_DEBUG_MODE=0

# OAR log file
LOG_FILE=/var/log/oar.log

# OAR Allowed networks
# Networks or hosts allowed to submit jobs to OAR and compute nodes may be specified here
ALLOWED_NETWORKS= 127.0.0.1/32 0.0.0.0/0

# Set the granularity of the OAR accounting feature (in seconds)
# Default is 1 day (86400s)
#ACCOUNTING_WINDOW= 86400

# OAR information may be notified by email to the administror
# set accordingly to your configuration and uncomment the next lines to
# activate the feature.
#MAIL_SMTP_SERVER = smtp.serveur.com
# You can specify several recipients with a comma between each email address
#MAIL_RECIPIENT = user@domain.com
#MAIL_SENDER = oar@domain.com

# Set the timeout for the prologue and epilogue execution on computing nodes
#PROLOGUE_EPILOGUE_TIMEOUT = 60

# Files to execute before and after each job on the first computing node (default is ~oar/oar_prologue ans ~oar/oar_epilogue)
#PROLOGUE_EXEC_FILE = /path/to/prog
#EPILOGUE_EXEC_FILE = /path/to/prog

# Set the timeout for the prologue and epilogue execution on the OAR server
#SERVER_PROLOGUE_EPILOGUE_TIMEOUT = 60

# Files to execute before and after each job on the OAR server
#SERVER_PROLOGUE_EXEC_FILE = /path/to/prog
#SERVER_EPILOGUE_EXEC_FILE = /path/to/prog

# Set the frequency for checking Alive and Suspected resources (0 means never)
FINAUD_FREQUENCY = 300

# Set time after which resources become Dead (default is 0 and it means never) 
#DEAD_SWITCH_TIME = 600

# Time to wait when a reservation has not got all resources that it has reserved
# (some resources could have become Suspected or Absent since the job submission)
# before to launch the job in the remaining resources
#RESERVATION_WAITING_RESOURCES_TIMEOUT = 300

# Maximum of seconds used by a scheduler
SCHEDULER_TIMEOUT = 10

# Time to add between each jobs (time for administration tasks or time to let computers to reboot)
SCHEDULER_JOB_SECURITY_TIME = 1

# Minimum time in seconds that can be considered like a hole where a job could be scheduled in
SCHEDULER_GANTT_HOLE_MINIMUM_TIME = 300

# You can add an order preference on resource assigned by the system(SQL ORDER syntax)
SCHEDULER_RESOURCE_ORDER = suspended_jobs ASC, switch ASC, network_address DESC, resource_id ASC

# This says to the scheduler to treate resources of these types, where there is
# a suspended job, like free ones. So some other jobs can be scheduled on these
# resources. (list resource types separate with spaces; Default value is
# nothing so no other job can be scheduled on suspended job resources)
#SCHEDULER_AVAILABLE_SUSPENDED_RESOURCE_TYPE = default licence VLAN
SCHEDULER_AVAILABLE_SUSPENDED_RESOURCE_TYPE = default

# Name of the perl script that manages suspend/resume. You have to install your
# script in $OARDIR and give only the name of the file without the entire path.
# (default is suspend_resume_manager.pl)
#SUSPEND_RESUME_FILE = suspend_resume_manager.pl


###############################################################################
# If you want to manage starting and stopping node feature. OAR gives you
# this API:

# When OAR scheduler wants some nodes to wake up then it launches this command
# with arguments : number_of_nodes_to_wake_up list_of_nodes(the scheduler looks
# at the cm_availability field in resources table to know if the node
# will be started for enough time)
#SCHEDULER_NODE_MANAGER_WAKE_UP_CMD = /path/to/the/command with your args

# When OAR considers that some nodes can be shut down, it launches this command with
# the node list in arguments
#SCHEDULER_NODE_MANAGER_SLEEP_CMD = /path/to/the/command args

# Parameters for the scheduler to decide when a node is idle.
# Number of seconds since the last job was terminated on nodes
#SCHEDULER_NODE_MANAGER_IDLE_TIME = 600

# Parameters for the scheduler to decide if a node will have enough time to sleep.
# Number of seconds before the next job
#SCHEDULER_NODE_MANAGER_SLEEP_TIME = 600

###############################################################################

# Indicate the name of the database field that contains the cpu number of the node.
# If this option is set then users must use oarsh instead of ssh to walk on each nodes that they have reserved via oarsub.
# Look at Tools/oarsh/README
#CPUSET_RESOURCE_PROPERTY_DB_FIELD = cpuset

# Name of the perl script that manages cpuset. You have to install your script
# in $OARDIR and give only the name of the file without the entire path.
# (default is cpuset_manager.pl which handles the linux kernel cpuset)
#CPUSET_FILE = cpuset_manager.pl

# If you have installed taktuk and want to use it to manage cpusets
# then give the full command path (with your options except "-m" and "-o").
# You don t also have to give any taktuk command.
#CPUSET_TAKTUK_CMD = /usr/bin/taktuk -s 

# Command to use to connect to other nodes (default is "ssh" in the PATH)
#OPENSSH_CMD = /usr/bin/ssh

#DESKTOP_COMPUTING_ALLOW_CREATE_NODE=0
#DESKTOP_COMPUTING_EXPIRY=300
#STAGEOUT_DIR=/var/lib/oar/stageouts/
#STAGEIN_DIR=/var/lib/oar/stageins
#STAGEIN_CACHE_EXPIRY=144

